<?php

// Generated by Haxe 3.3.0
class sys_net_Socket {
	public function __construct() {
		if(!php_Boot::$skip_constructor) {
		$GLOBALS['%s']->push("sys.net.Socket::new");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->input = new sys_io_FileInput(null);
		$this->output = new sys_io_FileOutput(null);
		$this->protocol = "tcp";
		$GLOBALS['%s']->pop();
	}}
	public $__s;
	public $protocol;
	public $input;
	public $output;
	public $custom;
	public function assignHandler() {
		$GLOBALS['%s']->push("sys.net.Socket::assignHandler");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->input->__f = $this->__s;
		$this->output->__f = $this->__s;
		$GLOBALS['%s']->pop();
	}
	public function close() {
		$GLOBALS['%s']->push("sys.net.Socket::close");
		$__hx__spos = $GLOBALS['%s']->length;
		fclose($this->__s);
		{
			$this->input->__f = null;
			$this->output->__f = null;
		}
		$this->input->close();
		$this->output->close();
		$GLOBALS['%s']->pop();
	}
	public function read() {
		$GLOBALS['%s']->push("sys.net.Socket::read");
		$__hx__spos = $GLOBALS['%s']->length;
		$b = "";
		while (!feof($this->__s)) $b .= fgets($this->__s);
		{
			$GLOBALS['%s']->pop();
			return $b;
		}
		$GLOBALS['%s']->pop();
	}
	public function write($content) {
		$GLOBALS['%s']->push("sys.net.Socket::write");
		$__hx__spos = $GLOBALS['%s']->length;
		fwrite($this->__s, $content);
		{
			$GLOBALS['%s']->pop();
			return;
		}
		$GLOBALS['%s']->pop();
	}
	public function connect($host, $port) {
		$GLOBALS['%s']->push("sys.net.Socket::connect");
		$__hx__spos = $GLOBALS['%s']->length;
		$errs = null;
		$errn = null;
		$r = stream_socket_client(_hx_string_or_null($this->protocol) . "://" . _hx_string_or_null($host->_ip) . ":" . _hx_string_rec($port, ""), $errn, $errs);
		sys_net_Socket::checkError($r, $errn, $errs);
		$this->__s = $r;
		$this->assignHandler();
		$GLOBALS['%s']->pop();
	}
	public function listen($connections) {
		$GLOBALS['%s']->push("sys.net.Socket::listen");
		$__hx__spos = $GLOBALS['%s']->length;
		throw new HException("Not implemented");
		$GLOBALS['%s']->pop();
	}
	public function shutdown($read, $write) {
		$GLOBALS['%s']->push("sys.net.Socket::shutdown");
		$__hx__spos = $GLOBALS['%s']->length;
		$r = null;
		$tmp = function_exists("stream_socket_shutdown");
		if($tmp) {
			$rw = null;
			$tmp1 = null;
			if($read) {
				$tmp1 = $write;
			} else {
				$tmp1 = false;
			}
			if($tmp1) {
				$rw = 2;
			} else {
				if($write) {
					$rw = 1;
				} else {
					if($read) {
						$rw = 0;
					} else {
						$rw = 2;
					}
				}
			}
			$r = stream_socket_shutdown($this->__s, $rw);
		} else {
			$r = fclose($this->__s);
		}
		sys_net_Socket::checkError($r, 0, "Unable to Shutdown");
		$GLOBALS['%s']->pop();
	}
	public function bind($host, $port) {
		$GLOBALS['%s']->push("sys.net.Socket::bind");
		$__hx__spos = $GLOBALS['%s']->length;
		$errs = null;
		$errn = null;
		$r = stream_socket_server(_hx_string_or_null($this->protocol) . "://" . _hx_string_or_null($host->_ip) . ":" . _hx_string_rec($port, ""), $errn, $errs, (($this->protocol === "udp") ? STREAM_SERVER_BIND : STREAM_SERVER_BIND | STREAM_SERVER_LISTEN));
		sys_net_Socket::checkError($r, $errn, $errs);
		$this->__s = $r;
		$this->assignHandler();
		$GLOBALS['%s']->pop();
	}
	public function accept() {
		$GLOBALS['%s']->push("sys.net.Socket::accept");
		$__hx__spos = $GLOBALS['%s']->length;
		$r = stream_socket_accept($this->__s);
		sys_net_Socket::checkError($r, 0, "Unable to accept connections on socket");
		$s = new sys_net_Socket();
		$s->__s = $r;
		$s->assignHandler();
		{
			$GLOBALS['%s']->pop();
			return $s;
		}
		$GLOBALS['%s']->pop();
	}
	public function hpOfString($s) {
		$GLOBALS['%s']->push("sys.net.Socket::hpOfString");
		$__hx__spos = $GLOBALS['%s']->length;
		$parts = _hx_explode(":", $s);
		$tmp = $parts->length === 2;
		if($tmp) {
			$tmp1 = $parts[0];
			$tmp2 = new sys_net_Host($tmp1);
			$tmp3 = $parts[1];
			$tmp4 = Std::parseInt($tmp3);
			{
				$tmp5 = _hx_anonymous(array("host" => $tmp2, "port" => $tmp4));
				$GLOBALS['%s']->pop();
				return $tmp5;
			}
		} else {
			$tmp5 = _hx_substr($parts[1], 2, null);
			$tmp6 = new sys_net_Host($tmp5);
			$tmp7 = $parts[2];
			$tmp8 = Std::parseInt($tmp7);
			{
				$tmp2 = _hx_anonymous(array("host" => $tmp6, "port" => $tmp8));
				$GLOBALS['%s']->pop();
				return $tmp2;
			}
		}
		$GLOBALS['%s']->pop();
	}
	public function peer() {
		$GLOBALS['%s']->push("sys.net.Socket::peer");
		$__hx__spos = $GLOBALS['%s']->length;
		$r = stream_socket_get_name($this->__s, true);
		sys_net_Socket::checkError($r, 0, "Unable to retrieve the peer name");
		{
			$tmp = $this->hpOfString($r);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function host() {
		$GLOBALS['%s']->push("sys.net.Socket::host");
		$__hx__spos = $GLOBALS['%s']->length;
		$r = stream_socket_get_name($this->__s, false);
		sys_net_Socket::checkError($r, 0, "Unable to retrieve the host name");
		{
			$tmp = $this->hpOfString($r);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function setTimeout($timeout) {
		$GLOBALS['%s']->push("sys.net.Socket::setTimeout");
		$__hx__spos = $GLOBALS['%s']->length;
		$s = Std::int($timeout);
		$ms = Std::int(($timeout - $s) * 1000000);
		$r = stream_set_timeout($this->__s, $s, $ms);
		sys_net_Socket::checkError($r, 0, "Unable to set timeout");
		$GLOBALS['%s']->pop();
	}
	public function setBlocking($b) {
		$GLOBALS['%s']->push("sys.net.Socket::setBlocking");
		$__hx__spos = $GLOBALS['%s']->length;
		$r = stream_set_blocking($this->__s, $b);
		sys_net_Socket::checkError($r, 0, "Unable to block");
		$GLOBALS['%s']->pop();
	}
	public function setFastSend($b) {
		$GLOBALS['%s']->push("sys.net.Socket::setFastSend");
		$__hx__spos = $GLOBALS['%s']->length;
		throw new HException("Not implemented");
		$GLOBALS['%s']->pop();
	}
	public function waitForRead() {
		$GLOBALS['%s']->push("sys.net.Socket::waitForRead");
		$__hx__spos = $GLOBALS['%s']->length;
		sys_net_Socket::select((new _hx_array(array($this))), null, null, null);
		$GLOBALS['%s']->pop();
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static function checkError($r, $code, $msg) {
		$GLOBALS['%s']->push("sys.net.Socket::checkError");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = !($r === false);
		if($tmp) {
			$GLOBALS['%s']->pop();
			return;
		}
		throw new HException(haxe_io_Error::Custom("Error [" . _hx_string_rec($code, "") . "]: " . _hx_string_or_null($msg)));
		$GLOBALS['%s']->pop();
	}
	static function getType($isUdp) {
		$GLOBALS['%s']->push("sys.net.Socket::getType");
		$__hx__spos = $GLOBALS['%s']->length;
		if($isUdp) {
			$tmp = SOCK_DGRAM;
			$GLOBALS['%s']->pop();
			return $tmp;
		} else {
			$tmp = SOCK_STREAM;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function getProtocol($protocol) {
		$GLOBALS['%s']->push("sys.net.Socket::getProtocol");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = getprotobyname($protocol);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function select($read, $write, $others, $timeout = null) {
		$GLOBALS['%s']->push("sys.net.Socket::select");
		$__hx__spos = $GLOBALS['%s']->length;
		throw new HException("Not implemented");
		$GLOBALS['%s']->pop();
	}
	function __toString() { return 'sys.net.Socket'; }
}
