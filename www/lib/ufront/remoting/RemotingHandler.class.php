<?php

// Generated by Haxe 3.3.0
class ufront_remoting_RemotingHandler implements ufront_app_UFRequestHandler{
	public function __construct() {
		if(!php_Boot::$skip_constructor) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::new");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->apiContexts = new HList();
		$this->apis = new HList();
		$GLOBALS['%s']->pop();
	}}
	public $apiContexts;
	public $apis;
	public $context;
	public function loadApi($api) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::loadApi");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->apis->push($api);
		$GLOBALS['%s']->pop();
	}
	public function loadApis($newAPIs) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::loadApis");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = $newAPIs->iterator();
		while(true) {
			$tmp1 = !$tmp->hasNext();
			if($tmp1) {
				break;
			}
			$api = $tmp->next();
			$this->apis->push($api);
			unset($tmp1,$api);
		}
		$GLOBALS['%s']->pop();
	}
	public function loadApiContext($apiContext) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::loadApiContext");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->apiContexts->push($apiContext);
		{
			$newAPIs = ufront_api_UFApiContext::getApisInContext($apiContext);
			{
				$tmp = $newAPIs->iterator();
				while(true) {
					$tmp1 = !$tmp->hasNext();
					if($tmp1) {
						break;
					}
					$api = $tmp->next();
					$this->apis->push($api);
					unset($tmp1,$api);
				}
			}
		}
		$GLOBALS['%s']->pop();
	}
	public function handleRequest($httpContext) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::handleRequest");
		$__hx__spos = $GLOBALS['%s']->length;
		$doneTrigger = new tink_core_FutureTrigger();
		$this1 = $httpContext->request->get_clientHeaders();
		$name = strtolower("X-Haxe-Remoting");
		$tmp = $this1->exists($name);
		if($tmp) {
			$r = $httpContext->response;
			$remotingResponse = null;
			$r->setOk();
			$path = null;
			$args = null;
			try {
				$this->initializeContext($httpContext->injector);
				$params = $httpContext->request->get_params();
				$tmp1 = !$params->exists("__x");
				if($tmp1) {
					throw new HException("Remoting call did not have parameter `__x` which describes which API call to make.  Aborting");
				}
				$remotingCall = ufront_core__MultiValueMap_MultiValueMap_Impl_::get($params, "__x");
				$tmp2 = $httpContext->request->get_files();
				$u = new ufront_remoting_RemotingUnserializer($remotingCall, $tmp2);
				try {
					$path = $u->unserialize();
					$args = $u->unserialize();
					{
						$_g1 = 0;
						$_g = $args->length;
						while($_g1 < $_g) {
							$i = $_g1++;
							$tmp3 = $args[$i];
							$baseUpload = Std::instance($tmp3, _hx_qtype("ufront.web.upload.BaseUpload"));
							$tmp4 = null;
							if($baseUpload !== null) {
								$tmp4 = $baseUpload->attachedUpload !== null;
							} else {
								$tmp4 = false;
							}
							if($tmp4) {
								$args[$i] = $baseUpload->attachedUpload;
							}
							unset($tmp4,$tmp3,$i,$baseUpload);
						}
					}
				}catch(Exception $__hx__e) {
					$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
					$e = $_ex_;
					{
						$GLOBALS['%e'] = (new _hx_array(array()));
						while($GLOBALS['%s']->length >= $__hx__spos) {
							$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
						}
						$GLOBALS['%s']->push($GLOBALS['%e'][0]);
						$tmp5 = Std::string($e);
						throw new HException("Unable to deserialize remoting call: " . _hx_string_or_null($tmp5) . ". Remoting call string: " . _hx_string_or_null($remotingCall));
					}
				}
				$apiCallFinished = $this->executeApiCall($path, $args, $this->context, $httpContext->actionContext);
				$remotingResponse = tink_core__Future_Future_Impl_::map($apiCallFinished, array(new _hx_lambda(array(), "ufront_remoting_RemotingHandler_0"), 'execute'), null);
			}catch(Exception $__hx__e) {
				$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
				$e1 = $_ex_;
				{
					$GLOBALS['%e'] = (new _hx_array(array()));
					while($GLOBALS['%s']->length >= $__hx__spos) {
						$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
					}
					$GLOBALS['%s']->push($GLOBALS['%e'][0]);
					$error = $e1;
					$apiNotFoundMessages = (new _hx_array(array("Invalid path", "No such object", "Can't access", "No such method")));
					$tmp7 = null;
					$tmp8 = null;
					$tmp9 = null;
					if($path !== null) {
						$tmp9 = $args !== null;
					} else {
						$tmp9 = false;
					}
					if($tmp9) {
						$tmp8 = Std::is($e1, _hx_qtype("String"));
					} else {
						$tmp8 = false;
					}
					if($tmp8) {
						$tmp7 = Lambda::exists($apiNotFoundMessages, array(new _hx_lambda(array(&$error), "ufront_remoting_RemotingHandler_1"), 'execute'));
					} else {
						$tmp7 = false;
					}
					if($tmp7) {
						$tmp10 = $path->join(".");
						$tmp11 = "Unable to access " . _hx_string_or_null($tmp10) . " - API Not Found (" . _hx_string_or_null($error) . "). See ";
						$tmp12 = Std::string($this->context->objects);
						$remotingResponse = tink_core__Future_Future_Impl_::sync(_hx_string_or_null($tmp11) . _hx_string_or_null($tmp12));
						$r->setNotFound();
					} else {
						$r->setInternalError();
						$tmp13 = $this->remotingError($e1, $httpContext);
						$remotingResponse = tink_core__Future_Future_Impl_::sync($tmp13);
					}
				}
			}
			$remotingResponse(array(new _hx_lambda(array(&$doneTrigger, &$httpContext, &$r), "ufront_remoting_RemotingHandler_2"), 'execute'));
		} else {
			$result1 = tink_core_Outcome::Success(tink_core_Noise::$Noise);
			if($doneTrigger->{"list"} !== null) {
				$list1 = $doneTrigger->{"list"};
				$doneTrigger->{"list"} = null;
				$doneTrigger->result = $result1;
				tink_core__Callback_CallbackList_Impl_::invoke($list1, $result1);
				tink_core__Callback_CallbackList_Impl_::clear($list1);
			}
		}
		{
			$tmp2 = (isset($doneTrigger->future) ? $doneTrigger->future: array($doneTrigger, "future"));
			$GLOBALS['%s']->pop();
			return $tmp2;
		}
		$GLOBALS['%s']->pop();
	}
	public function initializeContext($injector) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::initializeContext");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->context = new haxe_remoting_Context();
		{
			$tmp = $this->apiContexts->iterator();
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$apiContextClass = $tmp->next();
				$apiContext = $injector->_instantiate($apiContextClass);
				{
					$_g = 0;
					$_g1 = Reflect::fields($apiContext);
					while($_g < $_g1->length) {
						$fieldName = $_g1[$_g];
						++$_g;
						$api = Reflect::field($apiContext, $fieldName);
						$tmp2 = Reflect::isObject($api);
						if($tmp2) {
							$this->context->addObject($fieldName, $api, false);
						}
						unset($tmp2,$fieldName,$api);
					}
					unset($_g1,$_g);
				}
				unset($tmp1,$apiContextClass,$apiContext);
			}
		}
		{
			$tmp3 = $this->apis->iterator();
			while(true) {
				$tmp4 = !$tmp3->hasNext();
				if($tmp4) {
					break;
				}
				$apiClass = $tmp3->next();
				$className = Type::getClassName($apiClass);
				$api1 = $injector->_instantiate($apiClass);
				$this->context->addObject($className, $api1, false);
				unset($tmp4,$className,$apiClass,$api1);
			}
		}
		$GLOBALS['%s']->pop();
	}
	public function executeApiCall($path, $args, $remotingContext, $actionContext) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::executeApiCall");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = $path[0];
		$tmp1 = $remotingContext->objects->exists($tmp);
		if($tmp1 === false) {
			$tmp2 = $path->join(".");
			throw new HException("Invalid path " . _hx_string_or_null($tmp2));
		}
		$actionContext->handler = $this;
		$tmp3 = $path->length - 1;
		$actionContext->action = $path[$tmp3];
		$tmp4 = $path[0];
		$actionContext->controller = $remotingContext->objects->get($tmp4)->obj;
		$actionContext->args = $args;
		$returnType = null;
		try {
			$tmp5 = Type::getClass($actionContext->controller);
			$fieldsMeta = haxe_rtti_Meta::getFields($tmp5);
			$actionMeta = Reflect::field($fieldsMeta, $actionContext->action);
			$returnType = $actionMeta->returnType[0];
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e = $_ex_;
			{
				$GLOBALS['%e'] = (new _hx_array(array()));
				while($GLOBALS['%s']->length >= $__hx__spos) {
					$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
				}
				$GLOBALS['%s']->push($GLOBALS['%e'][0]);
				$tmp6 = Std::string($e);
				$actionContext->httpContext->messages->push(_hx_anonymous(array("msg" => "Failed to get metadata for API: " . _hx_string_or_null($tmp6), "pos" => _hx_anonymous(array("fileName" => "RemotingHandler.hx", "lineNumber" => 190, "className" => "ufront.remoting.RemotingHandler", "methodName" => "executeApiCall")), "type" => ufront_log_MessageType::$MError)));
				$actionContext->httpContext->messages->push(_hx_anonymous(array("msg" => "Assuming API call to " . _hx_string_or_null($actionContext->action) . " returns a regular value", "pos" => _hx_anonymous(array("fileName" => "RemotingHandler.hx", "lineNumber" => 191, "className" => "ufront.remoting.RemotingHandler", "methodName" => "executeApiCall")), "type" => ufront_log_MessageType::$MError)));
				$returnType = 0;
			}
		}
		$flags = $returnType;
		$result = $remotingContext->call($path, $args);
		$tmp7 = $flags & 1 << ufront_api_ApiReturnType::$ARTFuture->index;
		if($tmp7 !== 0) {
			$GLOBALS['%s']->pop();
			return $result;
		} else {
			$tmp8 = $flags & 1 << ufront_api_ApiReturnType::$ARTVoid->index;
			if($tmp8 !== 0) {
				$tmp2 = tink_core__Future_Future_Impl_::sync(null);
				$GLOBALS['%s']->pop();
				return $tmp2;
			} else {
				$tmp2 = tink_core__Future_Future_Impl_::sync($result);
				$GLOBALS['%s']->pop();
				return $tmp2;
			}
		}
		$GLOBALS['%s']->pop();
	}
	public function remotingError($e, $httpContext) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::remotingError");
		$__hx__spos = $GLOBALS['%s']->length;
		$httpContext->messages->push(_hx_anonymous(array("msg" => $e, "pos" => _hx_anonymous(array("fileName" => "RemotingHandler.hx", "lineNumber" => 209, "className" => "ufront.remoting.RemotingHandler", "methodName" => "remotingError")), "type" => ufront_log_MessageType::$MError)));
		$this1 = $httpContext->request->get_clientHeaders();
		$name = strtolower("X-Ufront-Remoting");
		$tmp = $this1->exists($name);
		if($tmp) {
			$s = new ufront_remoting_RemotingSerializer(ufront_remoting_RemotingDirection::$RDServerToClient);
			$s->serializeException($e);
			$tmp1 = $s->toString();
			$serializedException = "hxe" . _hx_string_or_null($tmp1);
			$tmp2 = haxe_CallStack::exceptionStack();
			$exceptionStack = haxe_CallStack::toString($tmp2);
			$tmp3 = ufront_remoting_RemotingSerializer::run($exceptionStack, ufront_remoting_RemotingDirection::$RDServerToClient);
			{
				$tmp4 = "hxs" . _hx_string_or_null($tmp3) . "\x0A" . _hx_string_or_null($serializedException);
				$GLOBALS['%s']->pop();
				return $tmp4;
			}
		} else {
			$s1 = new ufront_remoting_RemotingSerializer(ufront_remoting_RemotingDirection::$RDServerToClient);
			$s1->serializeException($e);
			$tmp4 = $s1->toString();
			{
				$tmp2 = "hxr" . _hx_string_or_null($tmp4);
				$GLOBALS['%s']->pop();
				return $tmp2;
			}
		}
		$GLOBALS['%s']->pop();
	}
	public function toString() {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::toString");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$GLOBALS['%s']->pop();
			return "ufront.remoting.RemotingHandler";
		}
		$GLOBALS['%s']->pop();
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return $this->toString(); }
}
function ufront_remoting_RemotingHandler_0($data) {
	{
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::handleRequest@115");
		$__hx__spos = $GLOBALS['%s']->length;
		$s = new ufront_remoting_RemotingSerializer(ufront_remoting_RemotingDirection::$RDServerToClient);
		$s->serialize($data);
		$tmp6 = $s->toString();
		{
			$tmp = "hxr" . _hx_string_or_null($tmp6);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
}
function ufront_remoting_RemotingHandler_1(&$error, $msg) {
	{
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::handleRequest@125");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = StringTools::startsWith($error, $msg);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
}
function ufront_remoting_RemotingHandler_2(&$doneTrigger, &$httpContext, &$r, $response) {
	{
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::handleRequest@135");
		$__hx__spos = $GLOBALS['%s']->length;
		$r->set_contentType("application/x-haxe-remoting");
		$r->clearContent();
		$r->write($response);
		$httpContext->completion |= 1 << ufront_web_context_RequestCompletion::$CRequestHandlersComplete->index;
		{
			$result = tink_core_Outcome::Success(tink_core_Noise::$Noise);
			if($doneTrigger->{"list"} !== null) {
				$list = $doneTrigger->{"list"};
				$doneTrigger->{"list"} = null;
				$doneTrigger->result = $result;
				tink_core__Callback_CallbackList_Impl_::invoke($list, $result);
				tink_core__Callback_CallbackList_Impl_::clear($list);
			}
		}
		$GLOBALS['%s']->pop();
	}
}
