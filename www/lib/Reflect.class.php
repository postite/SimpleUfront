<?php

// Generated by Haxe 3.3.0
class Reflect {
	public function __construct(){}
	static function hasField($o, $field) {
		$GLOBALS['%s']->push("Reflect::hasField");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = _hx_has_field($o, $field);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function field($o, $field) {
		$GLOBALS['%s']->push("Reflect::field");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = _hx_field($o, $field);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function setField($o, $field, $value) {
		$GLOBALS['%s']->push("Reflect::setField");
		$__hx__spos = $GLOBALS['%s']->length;
		$o->{$field} = $value;
		$GLOBALS['%s']->pop();
	}
	static function getProperty($o, $field) {
		$GLOBALS['%s']->push("Reflect::getProperty");
		$__hx__spos = $GLOBALS['%s']->length;
		if(null === $o) {
			$GLOBALS['%s']->pop();
			return null;
		}
		$cls = null;
		$tmp = Std::is($o, _hx_qtype("Class"));
		if($tmp) {
			$cls = $o->__tname__;
		} else {
			$cls = get_class($o);
		}
		$cls_vars = get_class_vars($cls);
		$tmp1 = isset($cls_vars['__properties__']) && isset($cls_vars['__properties__']['get_'.$field]) && ($field = $cls_vars['__properties__']['get_'.$field]);
		if($tmp1) {
			$tmp2 = $o->$field();
			$GLOBALS['%s']->pop();
			return $tmp2;
		} else {
			$tmp2 = _hx_field($o, $field);
			$GLOBALS['%s']->pop();
			return $tmp2;
		}
		$GLOBALS['%s']->pop();
	}
	static function setProperty($o, $field, $value) {
		$GLOBALS['%s']->push("Reflect::setProperty");
		$__hx__spos = $GLOBALS['%s']->length;
		if(null === $o) {
			$GLOBALS['%s']->pop();
			return;
		}
		$cls = null;
		$tmp = Std::is($o, _hx_qtype("Class"));
		if($tmp) {
			$cls = $o->__tname__;
		} else {
			$cls = get_class($o);
		}
		$cls_vars = get_class_vars($cls);
		$tmp1 = isset($cls_vars['__properties__']) && isset($cls_vars['__properties__']['set_'.$field]) && ($field = $cls_vars['__properties__']['set_'.$field]);
		if($tmp1) {
			$o->$field($value);
		} else {
			$o->{$field} = $value;
		}
		$GLOBALS['%s']->pop();
	}
	static function callMethod($o, $func, $args) {
		$GLOBALS['%s']->push("Reflect::callMethod");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = call_user_func_array(((is_callable($func)) ? $func : array($o, $func)), ((null === $args) ? array() : $args->a));
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function fields($o) {
		$GLOBALS['%s']->push("Reflect::fields");
		$__hx__spos = $GLOBALS['%s']->length;
		if($o === null) {
			$tmp = new _hx_array(array());
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$tmp = $o instanceof _hx_array;
		if($tmp) {
			$tmp2 = new _hx_array(array('concat','copy','insert','iterator','length','join','pop','push','remove','reverse','shift','slice','sort','splice','toString','unshift'));
			$GLOBALS['%s']->pop();
			return $tmp2;
		} else {
			$tmp1 = is_string($o);
			if($tmp1) {
				$tmp2 = new _hx_array(array('charAt','charCodeAt','indexOf','lastIndexOf','length','split','substr','toLowerCase','toString','toUpperCase'));
				$GLOBALS['%s']->pop();
				return $tmp2;
			} else {
				$tmp2 = new _hx_array(_hx_get_object_vars($o));
				$GLOBALS['%s']->pop();
				return $tmp2;
			}
		}
		$GLOBALS['%s']->pop();
	}
	static function isFunction($f) {
		$GLOBALS['%s']->push("Reflect::isFunction");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = !(is_array($f) && is_callable($f)) || _hx_is_lambda($f);
		if($tmp) {
			$tmp1 = null;
			$tmp2 = is_array($f);
			if($tmp2) {
				$o = $f[0];
				$field = $f[1];
				$tmp1 = _hx_has_field($o, $field);
			} else {
				$tmp1 = false;
			}
			if($tmp1) {
				$tmp3 = $f[1];
				{
					$tmp4 = $tmp3 !== "length";
					$GLOBALS['%s']->pop();
					return $tmp4;
				}
			} else {
				$GLOBALS['%s']->pop();
				return false;
			}
		} else {
			$GLOBALS['%s']->pop();
			return true;
		}
		$GLOBALS['%s']->pop();
	}
	static function compare($a, $b) {
		$GLOBALS['%s']->push("Reflect::compare");
		$__hx__spos = $GLOBALS['%s']->length;
		if((is_object($_t = $a) && ($_t instanceof Enum) ? $_t == $b : _hx_equal($_t, $b))) {
			$GLOBALS['%s']->pop();
			return 0;
		} else {
			$tmp = is_string($a);
			if($tmp) {
				$tmp2 = strcmp($a, $b);
				$GLOBALS['%s']->pop();
				return $tmp2;
			} else {
				if($a > $b) {
					$GLOBALS['%s']->pop();
					return 1;
				} else {
					$GLOBALS['%s']->pop();
					return -1;
				}
			}
		}
		$GLOBALS['%s']->pop();
	}
	static function compareMethods($f1, $f2) {
		$GLOBALS['%s']->push("Reflect::compareMethods");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = null;
		$tmp1 = is_array($f1);
		if($tmp1) {
			$tmp = is_array($f1);
		} else {
			$tmp = false;
		}
		if($tmp) {
			$tmp2 = $f1[0] === $f2[0] && $f1[1] == $f2[1];
			$GLOBALS['%s']->pop();
			return $tmp2;
		}
		$tmp2 = null;
		$tmp3 = is_string($f1);
		if($tmp3) {
			$tmp2 = is_string($f2);
		} else {
			$tmp2 = false;
		}
		if($tmp2) {
			$tmp4 = _hx_equal($f1, $f2);
			$GLOBALS['%s']->pop();
			return $tmp4;
		}
		{
			$GLOBALS['%s']->pop();
			return false;
		}
		$GLOBALS['%s']->pop();
	}
	static function isObject($v) {
		$GLOBALS['%s']->push("Reflect::isObject");
		$__hx__spos = $GLOBALS['%s']->length;
		if($v === null) {
			$GLOBALS['%s']->pop();
			return false;
		}
		$tmp = is_object($v);
		if($tmp) {
			$tmp1 = null;
			$tmp2 = !$v instanceof _hx_anonymous;
			if($tmp2) {
				$tmp3 = Type::getClass($v);
				$tmp1 = $tmp3 !== null;
			} else {
				$tmp1 = true;
			}
			if(!$tmp1) {
				$tmp4 = !$v instanceof _hx_class;
				if($tmp4) {
					$tmp3 = $v instanceof _hx_enum;
					$GLOBALS['%s']->pop();
					return $tmp3;
				} else {
					$GLOBALS['%s']->pop();
					return true;
				}
			} else {
				$GLOBALS['%s']->pop();
				return true;
			}
		}
		{
			$tmp2 = is_string($v) && !_hx_is_lambda($v);
			$GLOBALS['%s']->pop();
			return $tmp2;
		}
		$GLOBALS['%s']->pop();
	}
	static function isEnumValue($v) {
		$GLOBALS['%s']->push("Reflect::isEnumValue");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = $v instanceof Enum;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function deleteField($o, $field) {
		$GLOBALS['%s']->push("Reflect::deleteField");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = !_hx_has_field($o, $field);
		if($tmp) {
			$GLOBALS['%s']->pop();
			return false;
		}
		if(isset($o->__dynamics[$field])) unset($o->__dynamics[$field]); else if($o instanceof _hx_anonymous) unset($o->$field); else $o->$field = null;
		{
			$GLOBALS['%s']->pop();
			return true;
		}
		$GLOBALS['%s']->pop();
	}
	static function copy($o) {
		$GLOBALS['%s']->push("Reflect::copy");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = is_string($o);
		if($tmp) {
			$GLOBALS['%s']->pop();
			return $o;
		}
		$o2 = _hx_anonymous(array());
		{
			$_g = 0;
			$_g1 = Reflect::fields($o);
			while($_g < $_g1->length) {
				$f = $_g1[$_g];
				++$_g;
				{
					$value = Reflect::field($o, $f);
					$o2->{$f} = $value;
					unset($value);
				}
				unset($f);
			}
		}
		{
			$GLOBALS['%s']->pop();
			return $o2;
		}
		$GLOBALS['%s']->pop();
	}
	static function makeVarArgs($f) {
		$GLOBALS['%s']->push("Reflect::makeVarArgs");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = array(new _hx_lambda(array(&$f), '_hx_make_var_args'), 'execute');
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	function __toString() { return 'Reflect'; }
}
