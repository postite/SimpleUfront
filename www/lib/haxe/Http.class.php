<?php

// Generated by Haxe 3.3.0
class haxe_Http {
	public function __construct($url) {
		if(!isset($this->onData)) $this->onData = array(new _hx_lambda(array(&$this), "haxe_Http_0"), 'execute');
		if(!isset($this->onError)) $this->onError = array(new _hx_lambda(array(&$this), "haxe_Http_1"), 'execute');
		if(!isset($this->onStatus)) $this->onStatus = array(new _hx_lambda(array(&$this), "haxe_Http_2"), 'execute');
		if(!php_Boot::$skip_constructor) {
		$GLOBALS['%s']->push("haxe.Http::new");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->url = $url;
		$this->headers = new HList();
		$this->params = new HList();
		$this->cnxTimeout = 10;
		$this->noShutdown = !function_exists("stream_socket_shutdown");
		$GLOBALS['%s']->pop();
	}}
	public $url;
	public $responseData;
	public $noShutdown;
	public $cnxTimeout;
	public $responseHeaders;
	public $chunk_size;
	public $chunk_buf;
	public $file;
	public $postData;
	public $headers;
	public $params;
	public function setHeader($header, $value) {
		$GLOBALS['%s']->push("haxe.Http::setHeader");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->headers = Lambda::filter($this->headers, array(new _hx_lambda(array(&$header), "haxe_Http_3"), 'execute'));
		$this->headers->push(_hx_anonymous(array("header" => $header, "value" => $value)));
		{
			$GLOBALS['%s']->pop();
			return $this;
		}
		$GLOBALS['%s']->pop();
	}
	public function addHeader($header, $value) {
		$GLOBALS['%s']->push("haxe.Http::addHeader");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->headers->push(_hx_anonymous(array("header" => $header, "value" => $value)));
		{
			$GLOBALS['%s']->pop();
			return $this;
		}
		$GLOBALS['%s']->pop();
	}
	public function setParameter($param, $value) {
		$GLOBALS['%s']->push("haxe.Http::setParameter");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->params = Lambda::filter($this->params, array(new _hx_lambda(array(&$param), "haxe_Http_4"), 'execute'));
		$this->params->push(_hx_anonymous(array("param" => $param, "value" => $value)));
		{
			$GLOBALS['%s']->pop();
			return $this;
		}
		$GLOBALS['%s']->pop();
	}
	public function addParameter($param, $value) {
		$GLOBALS['%s']->push("haxe.Http::addParameter");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->params->push(_hx_anonymous(array("param" => $param, "value" => $value)));
		{
			$GLOBALS['%s']->pop();
			return $this;
		}
		$GLOBALS['%s']->pop();
	}
	public function setPostData($data) {
		$GLOBALS['%s']->push("haxe.Http::setPostData");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->postData = $data;
		{
			$GLOBALS['%s']->pop();
			return $this;
		}
		$GLOBALS['%s']->pop();
	}
	public function request($post = null) {
		$GLOBALS['%s']->push("haxe.Http::request");
		$__hx__spos = $GLOBALS['%s']->length;
		$_gthis = $this;
		$me = $this;
		$output = new haxe_io_BytesOutput();
		$old = (isset($this->onError) ? $this->onError: array($this, "onError"));
		$err = false;
		$this->onError = array(new _hx_lambda(array(&$_gthis, &$err, &$me, &$old, &$output), "haxe_Http_5"), 'execute');
		$this->customRequest($post, $output, null, null);
		if(!$err) {
			$tmp = $me->responseData = $output->getBytes()->toString();
			$me->onData($tmp);
		}
		$GLOBALS['%s']->pop();
	}
	public function fileTransfert($argname, $filename, $file, $size, $mimeType = null) {
		$GLOBALS['%s']->push("haxe.Http::fileTransfert");
		$__hx__spos = $GLOBALS['%s']->length;
		if($mimeType === null) {
			$mimeType = "application/octet-stream";
		}
		$this->fileTransfer($argname, $filename, $file, $size, $mimeType);
		$GLOBALS['%s']->pop();
	}
	public function fileTransfer($argname, $filename, $file, $size, $mimeType = null) {
		$GLOBALS['%s']->push("haxe.Http::fileTransfer");
		$__hx__spos = $GLOBALS['%s']->length;
		if($mimeType === null) {
			$mimeType = "application/octet-stream";
		}
		$this->file = _hx_anonymous(array("param" => $argname, "filename" => $filename, "io" => $file, "size" => $size, "mimeType" => $mimeType));
		$GLOBALS['%s']->pop();
	}
	public function customRequest($post, $api, $sock = null, $method = null) {
		$GLOBALS['%s']->push("haxe.Http::customRequest");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->responseData = null;
		$url_regexp = new EReg("^(https?://)?([a-zA-Z\\.0-9_-]+)(:[0-9]+)?(.*)\$", "");
		$tmp = !$url_regexp->match($this->url);
		if($tmp) {
			$this->onError("Invalid URL");
			{
				$GLOBALS['%s']->pop();
				return;
			}
		}
		$tmp1 = $url_regexp->matched(1);
		$secure = $tmp1 === "https://";
		if($sock === null) {
			if($secure) {
				$sock = new php_net_SslSocket();
			} else {
				$sock = new sys_net_Socket();
			}
		}
		$host = $url_regexp->matched(2);
		$portString = $url_regexp->matched(3);
		$request = $url_regexp->matched(4);
		$tmp2 = $request === "";
		if($tmp2) {
			$request = "/";
		}
		$port = null;
		$tmp3 = null;
		if($portString !== null) {
			$tmp3 = $portString === "";
		} else {
			$tmp3 = true;
		}
		if($tmp3) {
			if($secure) {
				$port = 443;
			} else {
				$port = 80;
			}
		} else {
			$tmp4 = strlen($portString) - 1;
			$tmp5 = _hx_substr($portString, 1, $tmp4);
			$port = Std::parseInt($tmp5);
		}
		$data = null;
		$multipart = _hx_field($this, "file") !== null;
		$boundary = null;
		$uri = null;
		if($multipart) {
			$post = true;
			$tmp6 = Std::random(1000);
			$tmp7 = Std::string($tmp6);
			$tmp8 = Std::random(1000);
			$tmp9 = Std::string($tmp8);
			$tmp10 = _hx_string_or_null($tmp7) . _hx_string_or_null($tmp9);
			$tmp11 = Std::random(1000);
			$tmp12 = Std::string($tmp11);
			$tmp13 = _hx_string_or_null($tmp10) . _hx_string_or_null($tmp12);
			$tmp14 = Std::random(1000);
			$tmp15 = Std::string($tmp14);
			$boundary = _hx_string_or_null($tmp13) . _hx_string_or_null($tmp15);
			while(strlen($boundary) < 38) {
				$boundary = "-" . _hx_string_or_null($boundary);
			}
			$b = new StringBuf();
			{
				$tmp16 = $this->params->iterator();
				while(true) {
					$tmp17 = !$tmp16->hasNext();
					if($tmp17) {
						break;
					}
					$p = $tmp16->next();
					$b->add("--");
					$b->add($boundary);
					$b->add("\x0D\x0A");
					$b->add("Content-Disposition: form-data; name=\"");
					$b->add($p->param);
					$b->add("\"");
					$b->add("\x0D\x0A");
					$b->add("\x0D\x0A");
					$b->add($p->value);
					$b->add("\x0D\x0A");
					unset($tmp17,$p);
				}
			}
			$b->add("--");
			$b->add($boundary);
			$b->add("\x0D\x0A");
			$b->add("Content-Disposition: form-data; name=\"");
			$b->add($this->file->param);
			$b->add("\"; filename=\"");
			$b->add($this->file->filename);
			$b->add("\"");
			$b->add("\x0D\x0A");
			$b->add("Content-Type: " . _hx_string_or_null($this->file->mimeType) . "\x0D\x0A" . "\x0D\x0A");
			$uri = $b->b;
		} else {
			$tmp18 = $this->params->iterator();
			while(true) {
				$tmp19 = !$tmp18->hasNext();
				if($tmp19) {
					break;
				}
				$p1 = $tmp18->next();
				$tmp20 = $uri === null;
				if($tmp20) {
					$uri = "";
				} else {
					$uri .= "&";
				}
				$tmp21 = rawurlencode($p1->param);
				$tmp22 = _hx_string_or_null($tmp21) . "=";
				$tmp23 = rawurlencode($p1->value);
				$uri .= _hx_string_or_null($tmp22) . _hx_string_or_null($tmp23);
				unset($tmp23,$tmp22,$tmp21,$tmp20,$tmp19,$p1);
			}
		}
		$b1 = new StringBuf();
		if($method !== null) {
			$b1->add($method);
			$b1->add(" ");
		} else {
			if($post) {
				$b1->add("POST ");
			} else {
				$b1->add("GET ");
			}
		}
		if(_hx_field(_hx_qtype("haxe.Http"), "PROXY") !== null) {
			$b1->add("http://");
			$b1->add($host);
			if($port !== 80) {
				$b1->add(":");
				$b1->add($port);
			}
		}
		$b1->add($request);
		$tmp24 = null;
		if(!$post) {
			$tmp24 = $uri !== null;
		} else {
			$tmp24 = false;
		}
		if($tmp24) {
			$tmp25 = _hx_index_of($request, "?", 0);
			if($tmp25 >= 0) {
				$b1->add("&");
			} else {
				$b1->add("?");
			}
			$b1->add($uri);
		}
		$b1->add(" HTTP/1.1\x0D\x0AHost: " . _hx_string_or_null($host) . "\x0D\x0A");
		if($this->postData !== null) {
			$tmp26 = "Content-Length: " . _hx_string_rec(strlen($this->postData), "") . "\x0D\x0A";
			$b1->add($tmp26);
		} else {
			$tmp27 = null;
			if($post) {
				$tmp27 = $uri !== null;
			} else {
				$tmp27 = false;
			}
			if($tmp27) {
				$tmp28 = null;
				if(!$multipart) {
					$tmp28 = !Lambda::exists($this->headers, array(new _hx_lambda(array(), "haxe_Http_6"), 'execute'));
				} else {
					$tmp28 = true;
				}
				if($tmp28) {
					$b1->add("Content-Type: ");
					if($multipart) {
						$b1->add("multipart/form-data");
						$b1->add("; boundary=");
						$b1->add($boundary);
					} else {
						$b1->add("application/x-www-form-urlencoded");
					}
					$b1->add("\x0D\x0A");
				}
				if($multipart) {
					$tmp29 = "Content-Length: " . _hx_string_rec((strlen($uri) + $this->file->size + strlen($boundary) + 6), "");
					$b1->add(_hx_string_or_null($tmp29) . "\x0D\x0A");
				} else {
					$tmp30 = "Content-Length: " . _hx_string_rec(strlen($uri), "") . "\x0D\x0A";
					$b1->add($tmp30);
				}
			}
		}
		$b1->add("Connection: close\x0D\x0A");
		{
			$tmp31 = $this->headers->iterator();
			while(true) {
				$tmp32 = !$tmp31->hasNext();
				if($tmp32) {
					break;
				}
				$h1 = $tmp31->next();
				$b1->add($h1->header);
				$b1->add(": ");
				$b1->add($h1->value);
				$b1->add("\x0D\x0A");
				unset($tmp32,$h1);
			}
		}
		$b1->add("\x0D\x0A");
		if($this->postData !== null) {
			$b1->add($this->postData);
		} else {
			$tmp33 = null;
			if($post) {
				$tmp33 = $uri !== null;
			} else {
				$tmp33 = false;
			}
			if($tmp33) {
				$b1->add($uri);
			}
		}
		try {
			if(_hx_field(_hx_qtype("haxe.Http"), "PROXY") !== null) {
				$sock->connect(new sys_net_Host(haxe_Http::$PROXY->host), haxe_Http::$PROXY->port);
			} else {
				$sock->connect(new sys_net_Host($host), $port);
			}
			$sock->write($b1->b);
			if($multipart) {
				$bufsize = 4096;
				$buf = haxe_io_Bytes::alloc($bufsize);
				while($this->file->size > 0) {
					$size = null;
					if($this->file->size > $bufsize) {
						$size = $bufsize;
					} else {
						$size = $this->file->size;
					}
					$len = 0;
					try {
						$len = $this->file->io->readBytes($buf, 0, $size);
					}catch(Exception $__hx__e) {
						$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
						if(($e = $_ex_) instanceof haxe_io_Eof){
							$GLOBALS['%e'] = (new _hx_array(array()));
							while($GLOBALS['%s']->length >= $__hx__spos) {
								$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
							}
							$GLOBALS['%s']->push($GLOBALS['%e'][0]);
							break;
						} else throw $__hx__e;;
					}
					$sock->output->writeFullBytes($buf, 0, $len);
					$this->file->size -= $len;
					unset($size,$len,$e);
				}
				$sock->write("\x0D\x0A");
				$sock->write("--");
				$sock->write($boundary);
				$sock->write("--");
			}
			$this->readHttpResponse($api, $sock);
			$sock->close();
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e1 = $_ex_;
			{
				$GLOBALS['%e'] = (new _hx_array(array()));
				while($GLOBALS['%s']->length >= $__hx__spos) {
					$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
				}
				$GLOBALS['%s']->push($GLOBALS['%e'][0]);
				try {
					$sock->close();
				}catch(Exception $__hx__e) {
					$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
					$e2 = $_ex_;
					{
						$GLOBALS['%e'] = (new _hx_array(array()));
						while($GLOBALS['%s']->length >= $__hx__spos) {
							$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
						}
						$GLOBALS['%s']->push($GLOBALS['%e'][0]);
					}
				}
				$tmp34 = Std::string($e1);
				$this->onError($tmp34);
			}
		}
		$GLOBALS['%s']->pop();
	}
	public function readHttpResponse($api, $sock) {
		$GLOBALS['%s']->push("haxe.Http::readHttpResponse");
		$__hx__spos = $GLOBALS['%s']->length;
		$b = new haxe_io_BytesBuffer();
		$k = 4;
		$s = haxe_io_Bytes::alloc(4);
		$sock->setTimeout($this->cnxTimeout);
		while(true) {
			$p = $sock->input->readBytes($s, 0, $k);
			while($p !== $k) {
				$tmp = $sock->input->readBytes($s, $p, $k - $p);
				$p += $tmp;
				unset($tmp);
			}
			{
				$tmp1 = null;
				if($k >= 0) {
					$tmp1 = $k > $s->length;
				} else {
					$tmp1 = true;
				}
				if($tmp1) {
					throw new HException(haxe_io_Error::$OutsideBounds);
				}
				$s1 = substr($s->b->s, 0, $k);
				$x = new php__BytesData_Wrapper($s1);
				$b->b .= _hx_string_or_null($x->s);
				unset($x,$tmp1,$s1);
			}
			switch($k) {
			case 1:{
				$c = ord($s->b->s[0]);
				if($c === 10) {
					break 2;
				}
				if($c === 13) {
					$k = 3;
				} else {
					$k = 4;
				}
			}break;
			case 2:{
				$c1 = ord($s->b->s[1]);
				if($c1 === 10) {
					$tmp2 = ord($s->b->s[0]);
					if($tmp2 === 13) {
						break 2;
					}
					$k = 4;
				} else {
					if($c1 === 13) {
						$k = 3;
					} else {
						$k = 4;
					}
				}
			}break;
			case 3:{
				$c2 = ord($s->b->s[2]);
				if($c2 === 10) {
					$tmp3 = ord($s->b->s[1]);
					if($tmp3 !== 13) {
						$k = 4;
					} else {
						$tmp4 = ord($s->b->s[0]);
						if($tmp4 !== 10) {
							$k = 2;
						} else {
							break 2;
						}
					}
				} else {
					if($c2 === 13) {
						$tmp5 = null;
						$tmp6 = ord($s->b->s[1]);
						if($tmp6 === 10) {
							$tmp7 = ord($s->b->s[0]);
							$tmp5 = $tmp7 !== 13;
						} else {
							$tmp5 = true;
						}
						if($tmp5) {
							$k = 1;
						} else {
							$k = 3;
						}
					} else {
						$k = 4;
					}
				}
			}break;
			case 4:{
				$c3 = ord($s->b->s[3]);
				if($c3 === 10) {
					$tmp8 = ord($s->b->s[2]);
					if($tmp8 !== 13) {
						continue 2;
					} else {
						$tmp9 = null;
						$tmp10 = ord($s->b->s[1]);
						if($tmp10 === 10) {
							$tmp11 = ord($s->b->s[0]);
							$tmp9 = $tmp11 !== 13;
						} else {
							$tmp9 = true;
						}
						if($tmp9) {
							$k = 2;
						} else {
							break 2;
						}
					}
				} else {
					if($c3 === 13) {
						$tmp12 = null;
						$tmp13 = ord($s->b->s[2]);
						if($tmp13 === 10) {
							$tmp14 = ord($s->b->s[1]);
							$tmp12 = $tmp14 !== 13;
						} else {
							$tmp12 = true;
						}
						if($tmp12) {
							$k = 3;
						} else {
							$k = 1;
						}
					}
				}
			}break;
			}
			unset($p);
		}
		$headers = _hx_explode("\x0D\x0A", $b->getBytes()->toString());
		$response = $headers->shift();
		$rp = _hx_explode(" ", $response);
		$tmp15 = $rp[1];
		$status = Std::parseInt($tmp15);
		$tmp16 = null;
		if($status !== 0) {
			$tmp16 = $status === null;
		} else {
			$tmp16 = true;
		}
		if($tmp16) {
			throw new HException("Response status error");
		}
		$headers->pop();
		$headers->pop();
		$this->responseHeaders = new haxe_ds_StringMap();
		$size = null;
		$chunked = false;
		{
			$_g = 0;
			while($_g < $headers->length) {
				$hline = $headers[$_g];
				++$_g;
				$a = _hx_explode(": ", $hline);
				$hname = $a->shift();
				$hval = null;
				$tmp17 = $a->length === 1;
				if($tmp17) {
					$hval = $a[0];
				} else {
					$hval = $a->join(": ");
				}
				$s2 = rtrim($hval);
				$hval = ltrim($s2);
				$this->responseHeaders->set($hname, $hval);
				{
					$_g1 = strtolower($hname);
					switch($_g1) {
					case "content-length":{
						$size = Std::parseInt($hval);
					}break;
					case "transfer-encoding":{
						$tmp18 = strtolower($hval);
						$chunked = $tmp18 === "chunked";
					}break;
					}
					unset($_g1);
				}
				unset($tmp17,$s2,$hval,$hname,$hline,$a);
			}
		}
		$this->onStatus($status);
		$chunk_re = new EReg("^([0-9A-Fa-f]+)[ ]*\x0D\x0A", "m");
		$this->chunk_size = null;
		$this->chunk_buf = null;
		$bufsize = 1024;
		$buf = haxe_io_Bytes::alloc($bufsize);
		if($chunked) {
			try {
				while(true) {
					$len = $sock->input->readBytes($buf, 0, $bufsize);
					$tmp19 = !$this->readChunk($chunk_re, $api, $buf, $len);
					if($tmp19) {
						break;
					}
					unset($tmp19,$len);
				}
			}catch(Exception $__hx__e) {
				$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
				if(($e = $_ex_) instanceof haxe_io_Eof){
					$GLOBALS['%e'] = (new _hx_array(array()));
					while($GLOBALS['%s']->length >= $__hx__spos) {
						$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
					}
					$GLOBALS['%s']->push($GLOBALS['%e'][0]);
					throw new HException("Transfer aborted");
				} else throw $__hx__e;;
			}
		} else {
			if($size === null) {
				$tmp20 = !$this->noShutdown;
				if($tmp20) {
					$sock->shutdown(false, true);
				}
				try {
					while(true) {
						$len1 = $sock->input->readBytes($buf, 0, $bufsize);
						$api->writeBytes($buf, 0, $len1);
						unset($len1);
					}
				}catch(Exception $__hx__e) {
					$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
					if(($e1 = $_ex_) instanceof haxe_io_Eof){
						$GLOBALS['%e'] = (new _hx_array(array()));
						while($GLOBALS['%s']->length >= $__hx__spos) {
							$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
						}
						$GLOBALS['%s']->push($GLOBALS['%e'][0]);
					} else throw $__hx__e;;
				}
			} else {
				$api->prepare($size);
				try {
					while($size > 0) {
						$tmp21 = null;
						if($size > $bufsize) {
							$tmp21 = $bufsize;
						} else {
							$tmp21 = $size;
						}
						$len2 = $sock->input->readBytes($buf, 0, $tmp21);
						$api->writeBytes($buf, 0, $len2);
						$size -= $len2;
						unset($tmp21,$len2);
					}
				}catch(Exception $__hx__e) {
					$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
					if(($e2 = $_ex_) instanceof haxe_io_Eof){
						$GLOBALS['%e'] = (new _hx_array(array()));
						while($GLOBALS['%s']->length >= $__hx__spos) {
							$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
						}
						$GLOBALS['%s']->push($GLOBALS['%e'][0]);
						throw new HException("Transfer aborted");
					} else throw $__hx__e;;
				}
			}
		}
		$tmp22 = null;
		if($chunked) {
			if($this->chunk_size === null) {
				$tmp22 = $this->chunk_buf !== null;
			} else {
				$tmp22 = true;
			}
		} else {
			$tmp22 = false;
		}
		if($tmp22) {
			throw new HException("Invalid chunk");
		}
		$tmp23 = null;
		if($status >= 200) {
			$tmp23 = $status >= 400;
		} else {
			$tmp23 = true;
		}
		if($tmp23) {
			throw new HException("Http Error #" . _hx_string_rec($status, ""));
		}
		$api->close();
		$GLOBALS['%s']->pop();
	}
	public function readChunk($chunk_re, $api, $buf, $len) {
		$GLOBALS['%s']->push("haxe.Http::readChunk");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = $this->chunk_size === null;
		if($tmp) {
			if($this->chunk_buf !== null) {
				$b = new haxe_io_BytesBuffer();
				$b->b .= _hx_string_or_null($this->chunk_buf->b->s);
				{
					$tmp1 = null;
					if($len >= 0) {
						$tmp1 = $len > $buf->length;
					} else {
						$tmp1 = true;
					}
					if($tmp1) {
						throw new HException(haxe_io_Error::$OutsideBounds);
					}
					$s = substr($buf->b->s, 0, $len);
					$x = new php__BytesData_Wrapper($s);
					$b->b .= _hx_string_or_null($x->s);
				}
				$buf = $b->getBytes();
				$len += $this->chunk_buf->length;
				$this->chunk_buf = null;
			}
			$tmp2 = $buf->toString();
			$tmp3 = $chunk_re->match($tmp2);
			if($tmp3) {
				$p = $chunk_re->matchedPos();
				$tmp4 = $p->len <= $len;
				if($tmp4) {
					$cstr = $chunk_re->matched(1);
					$this->chunk_size = Std::parseInt("0x" . _hx_string_or_null($cstr));
					if($cstr === "0") {
						$this->chunk_size = null;
						$this->chunk_buf = null;
						{
							$GLOBALS['%s']->pop();
							return false;
						}
					}
					$len -= $p->len;
					$tmp5 = $buf->sub($p->len, $len);
					{
						$tmp6 = $this->readChunk($chunk_re, $api, $tmp5, $len);
						$GLOBALS['%s']->pop();
						return $tmp6;
					}
				}
			}
			if($len > 10) {
				$this->onError("Invalid chunk");
				{
					$GLOBALS['%s']->pop();
					return false;
				}
			}
			$this->chunk_buf = $buf->sub(0, $len);
			{
				$GLOBALS['%s']->pop();
				return true;
			}
		}
		$tmp6 = $this->chunk_size > $len;
		if($tmp6) {
			$this->chunk_size -= $len;
			$api->writeBytes($buf, 0, $len);
			{
				$GLOBALS['%s']->pop();
				return true;
			}
		}
		$end = $this->chunk_size + 2;
		if($len >= $end) {
			$tmp7 = $this->chunk_size > 0;
			if($tmp7) {
				$api->writeBytes($buf, 0, $this->chunk_size);
			}
			$len -= $end;
			$this->chunk_size = null;
			if($len === 0) {
				$GLOBALS['%s']->pop();
				return true;
			}
			$tmp8 = $buf->sub($end, $len);
			{
				$tmp2 = $this->readChunk($chunk_re, $api, $tmp8, $len);
				$GLOBALS['%s']->pop();
				return $tmp2;
			}
		}
		$tmp9 = $this->chunk_size > 0;
		if($tmp9) {
			$api->writeBytes($buf, 0, $this->chunk_size);
		}
		$this->chunk_size -= $len;
		{
			$GLOBALS['%s']->pop();
			return true;
		}
		$GLOBALS['%s']->pop();
	}
	public function onData($data) { return call_user_func_array($this->onData, array($data)); }
	public $onData = null;
	public function onError($msg) { return call_user_func_array($this->onError, array($msg)); }
	public $onError = null;
	public function onStatus($status) { return call_user_func_array($this->onStatus, array($status)); }
	public $onStatus = null;
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $PROXY = null;
	static function requestUrl($url) {
		$GLOBALS['%s']->push("haxe.Http::requestUrl");
		$__hx__spos = $GLOBALS['%s']->length;
		$h = new haxe_Http($url);
		$r = null;
		$h->onData = array(new _hx_lambda(array(&$r), "haxe_Http_7"), 'execute');
		$h->onError = array(new _hx_lambda(array(), "haxe_Http_8"), 'execute');
		$h->request(false);
		{
			$GLOBALS['%s']->pop();
			return $r;
		}
		$GLOBALS['%s']->pop();
	}
	function __toString() { return 'haxe.Http'; }
}
function haxe_Http_0(&$__hx__this, $data) {
	{
		$GLOBALS['%s']->push("haxe.Http::new");
		$__hx__spos = $GLOBALS['%s']->length;
		$GLOBALS['%s']->pop();
	}
}
function haxe_Http_1(&$__hx__this, $msg) {
	{
		$GLOBALS['%s']->push("haxe.Http::new");
		$__hx__spos = $GLOBALS['%s']->length;
		$GLOBALS['%s']->pop();
	}
}
function haxe_Http_2(&$__hx__this, $status) {
	{
		$GLOBALS['%s']->push("haxe.Http::new");
		$__hx__spos = $GLOBALS['%s']->length;
		$GLOBALS['%s']->pop();
	}
}
function haxe_Http_3(&$header, $h) {
	{
		$GLOBALS['%s']->push("haxe.Http::setHeader@103");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = $h->header !== $header;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
}
function haxe_Http_4(&$param, $p) {
	{
		$GLOBALS['%s']->push("haxe.Http::setParameter@121");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = $p->param !== $param;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
}
function haxe_Http_5(&$_gthis, &$err, &$me, &$old, &$output, $e) {
	{
		$GLOBALS['%s']->push("haxe.Http::request@329");
		$__hx__spos = $GLOBALS['%s']->length;
		$me->responseData = $output->getBytes()->toString();
		$err = true;
		$_gthis->onError = $old;
		$_gthis->onError($e);
		$GLOBALS['%s']->pop();
	}
}
function haxe_Http_6($h) {
	{
		$GLOBALS['%s']->push("haxe.Http::customRequest@466");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = $h->header === "Content-Type";
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
}
function haxe_Http_7(&$r, $d) {
	{
		$GLOBALS['%s']->push("haxe.Http::requestUrl@770");
		$__hx__spos = $GLOBALS['%s']->length;
		$r = $d;
		$GLOBALS['%s']->pop();
	}
}
function haxe_Http_8($e) {
	{
		$GLOBALS['%s']->push("haxe.Http::requestUrl@773");
		$__hx__spos = $GLOBALS['%s']->length;
		throw new HException($e);
		$GLOBALS['%s']->pop();
	}
}
