<?php

// Generated by Haxe 3.3.0
class haxe_Json {
	public function __construct(){}
	static function parse($text) {
		$GLOBALS['%s']->push("haxe.Json::parse");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = haxe_Json::phpJsonDecode($text);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function stringify($value, $replacer = null, $space = null) {
		$GLOBALS['%s']->push("haxe.Json::stringify");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = haxe_Json::phpJsonEncode($value, $replacer, $space);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function phpJsonDecode($json) {
		$GLOBALS['%s']->push("haxe.Json::phpJsonDecode");
		$__hx__spos = $GLOBALS['%s']->length;
		$val = json_decode($json);
		{
			$tmp = haxe_Json::convertAfterDecode($val);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function convertAfterDecode($val) {
		$GLOBALS['%s']->push("haxe.Json::convertAfterDecode");
		$__hx__spos = $GLOBALS['%s']->length;
		$arr = null;
		$tmp = is_object($val);
		if($tmp) {
			$arr1 = php_Lib::associativeArrayOfObject($val);
			$arr = array_map((isset(haxe_Json::$convertAfterDecode) ? haxe_Json::$convertAfterDecode: array("haxe_Json", "convertAfterDecode")), $arr1);
			{
				$tmp2 = _hx_anonymous($arr);
				$GLOBALS['%s']->pop();
				return $tmp2;
			}
		} else {
			$tmp1 = is_array($val);
			if($tmp1) {
				$arr = array_map((isset(haxe_Json::$convertAfterDecode) ? haxe_Json::$convertAfterDecode: array("haxe_Json", "convertAfterDecode")), $val);
				{
					$tmp2 = new _hx_array($arr);
					$GLOBALS['%s']->pop();
					return $tmp2;
				}
			} else {
				$GLOBALS['%s']->pop();
				return $val;
			}
		}
		$GLOBALS['%s']->pop();
	}
	static function phpJsonEncode($val, $replacer = null, $space = null) {
		$GLOBALS['%s']->push("haxe.Json::phpJsonEncode");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = null;
		if(null === $replacer) {
			$tmp = null !== $space;
		} else {
			$tmp = true;
		}
		if($tmp) {
			$tmp2 = haxe_format_JsonPrinter::hprint($val, $replacer, $space);
			$GLOBALS['%s']->pop();
			return $tmp2;
		}
		$json = json_encode(haxe_Json::convertBeforeEncode($val));
		$tmp1 = ($json === false);
		if($tmp1) {
			throw new HException("invalid json");
		} else {
			$GLOBALS['%s']->pop();
			return $json;
		}
		$GLOBALS['%s']->pop();
	}
	static function convertBeforeEncode($val) {
		$GLOBALS['%s']->push("haxe.Json::convertBeforeEncode");
		$__hx__spos = $GLOBALS['%s']->length;
		$arr = null;
		$tmp = is_object($val);
		if($tmp) {
			$_g = get_class($val);
			switch($_g) {
			case "Date":{
				$tmp2 = Std::string($val);
				$GLOBALS['%s']->pop();
				return $tmp2;
			}break;
			case "HList":{
				$tmp1 = Lambda::harray($val);
				$arr = php_Lib::toPhpArray($tmp1);
			}break;
			case "IntMap":case "StringMap":{
				$arr = php_Lib::associativeArrayOfHash($val);
			}break;
			case "_hx_array":{
				$arr = php_Lib::toPhpArray($val);
			}break;
			case "_hx_enum":{
				$tmp2 = $val->index;
				$GLOBALS['%s']->pop();
				return $tmp2;
			}break;
			case "_hx_anonymous":case "stdClass":{
				$arr = php_Lib::associativeArrayOfObject($val);
			}break;
			default:{
				$arr = php_Lib::associativeArrayOfObject($val);
			}break;
			}
		} else {
			$tmp2 = is_array($val);
			if($tmp2) {
				$arr = $val;
			} else {
				$tmp3 = null;
				$tmp4 = is_float($val);
				if($tmp4) {
					$tmp3 = !is_finite($val);
				} else {
					$tmp3 = false;
				}
				if($tmp3) {
					$val = null;
				}
				{
					$GLOBALS['%s']->pop();
					return $val;
				}
			}
		}
		{
			$tmp2 = array_map((isset(haxe_Json::$convertBeforeEncode) ? haxe_Json::$convertBeforeEncode: array("haxe_Json", "convertBeforeEncode")), $arr);
			$GLOBALS['%s']->pop();
			return $tmp2;
		}
		$GLOBALS['%s']->pop();
	}
	static function phpMapArray($arr, $func) {
		$GLOBALS['%s']->push("haxe.Json::phpMapArray");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = array_map($func, $arr);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	function __toString() { return 'haxe.Json'; }
}
