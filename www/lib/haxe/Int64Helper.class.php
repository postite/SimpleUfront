<?php

// Generated by Haxe 3.3.0
class haxe_Int64Helper {
	public function __construct(){}
	static function parseString($sParam) {
		$GLOBALS['%s']->push("haxe.Int64Helper::parseString");
		$__hx__spos = $GLOBALS['%s']->length;
		$x = new haxe__Int64____Int64(0, 10);
		$base = $x;
		$x1 = new haxe__Int64____Int64(0, 0);
		$current = $x1;
		$x2 = new haxe__Int64____Int64(0, 1);
		$multiplier = $x2;
		$sIsNegative = false;
		$s = trim($sParam);
		$tmp = _hx_char_at($s, 0);
		if($tmp === "-") {
			$sIsNegative = true;
			$s = _hx_substring($s, 1, strlen($s));
		}
		$len = strlen($s);
		{
			$_g1 = 0;
			$_g = $len;
			while($_g1 < $_g) {
				$i = $_g1++;
				$tmp1 = _hx_char_code_at($s, $len - 1 - $i);
				$digitInt = $tmp1 - 48;
				$tmp2 = null;
				if($digitInt >= 0) {
					$tmp2 = $digitInt > 9;
				} else {
					$tmp2 = true;
				}
				if($tmp2) {
					throw new HException("NumberFormatError");
				}
				$x3 = new haxe__Int64____Int64($digitInt >> 31, $digitInt);
				$digit = $x3;
				if($sIsNegative) {
					$mask = 65535;
					$al = $multiplier->low & $mask;
					$ah = _hx_shift_right($multiplier->low, 16);
					$bl = $digit->low & $mask;
					$bh = _hx_shift_right($digit->low, 16);
					$p00 = haxe__Int32_Int32_Impl_::mul($al, $bl);
					$p10 = haxe__Int32_Int32_Impl_::mul($ah, $bl);
					$p01 = haxe__Int32_Int32_Impl_::mul($al, $bh);
					$p11 = haxe__Int32_Int32_Impl_::mul($ah, $bh);
					$low = $p00;
					$high = ($p11 + (_hx_shift_right($p01, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) + (_hx_shift_right($p10, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$tmp3 = $p01 << 16 << haxe__Int32_Int32_Impl_::$extraBits;
					$p01 = $tmp3 >> haxe__Int32_Int32_Impl_::$extraBits;
					$tmp4 = $low + $p01 << haxe__Int32_Int32_Impl_::$extraBits;
					$low = $tmp4 >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($low, $p01) < 0) {
						$ret = $high++;
						$tmp5 = $high << haxe__Int32_Int32_Impl_::$extraBits;
						$high = $tmp5 >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($tmp5,$ret);
					}
					$tmp6 = $p10 << 16 << haxe__Int32_Int32_Impl_::$extraBits;
					$p10 = $tmp6 >> haxe__Int32_Int32_Impl_::$extraBits;
					$tmp7 = $low + $p10 << haxe__Int32_Int32_Impl_::$extraBits;
					$low = $tmp7 >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($low, $p10) < 0) {
						$ret1 = $high++;
						$tmp8 = $high << haxe__Int32_Int32_Impl_::$extraBits;
						$high = $tmp8 >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($tmp8,$ret1);
					}
					$tmp9 = $high + (haxe__Int32_Int32_Impl_::mul($multiplier->low, $digit->high) + haxe__Int32_Int32_Impl_::mul($multiplier->high, $digit->low) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) << haxe__Int32_Int32_Impl_::$extraBits;
					$high = $tmp9 >> haxe__Int32_Int32_Impl_::$extraBits;
					$x4 = new haxe__Int64____Int64($high, $low);
					$b = $x4;
					$high1 = $current->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$low1 = $current->low - $b->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($current->low, $b->low) < 0) {
						$ret2 = $high1--;
						$tmp10 = $high1 << haxe__Int32_Int32_Impl_::$extraBits;
						$high1 = $tmp10 >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($tmp10,$ret2);
					}
					$x5 = new haxe__Int64____Int64($high1, $low1);
					$current = $x5;
					if(!($current->high < 0)) {
						throw new HException("NumberFormatError: Underflow");
					}
					unset($x5,$x4,$tmp9,$tmp7,$tmp6,$tmp4,$tmp3,$p11,$p10,$p01,$p00,$mask,$low1,$low,$high1,$high,$bl,$bh,$b,$al,$ah);
				} else {
					$mask1 = 65535;
					$al1 = $multiplier->low & $mask1;
					$ah1 = _hx_shift_right($multiplier->low, 16);
					$bl1 = $digit->low & $mask1;
					$bh1 = _hx_shift_right($digit->low, 16);
					$p001 = haxe__Int32_Int32_Impl_::mul($al1, $bl1);
					$p101 = haxe__Int32_Int32_Impl_::mul($ah1, $bl1);
					$p011 = haxe__Int32_Int32_Impl_::mul($al1, $bh1);
					$p111 = haxe__Int32_Int32_Impl_::mul($ah1, $bh1);
					$low2 = $p001;
					$high2 = ($p111 + (_hx_shift_right($p011, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) + (_hx_shift_right($p101, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$tmp11 = $p011 << 16 << haxe__Int32_Int32_Impl_::$extraBits;
					$p011 = $tmp11 >> haxe__Int32_Int32_Impl_::$extraBits;
					$tmp12 = $low2 + $p011 << haxe__Int32_Int32_Impl_::$extraBits;
					$low2 = $tmp12 >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($low2, $p011) < 0) {
						$ret3 = $high2++;
						$tmp13 = $high2 << haxe__Int32_Int32_Impl_::$extraBits;
						$high2 = $tmp13 >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($tmp13,$ret3);
					}
					$tmp14 = $p101 << 16 << haxe__Int32_Int32_Impl_::$extraBits;
					$p101 = $tmp14 >> haxe__Int32_Int32_Impl_::$extraBits;
					$tmp15 = $low2 + $p101 << haxe__Int32_Int32_Impl_::$extraBits;
					$low2 = $tmp15 >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($low2, $p101) < 0) {
						$ret4 = $high2++;
						$tmp16 = $high2 << haxe__Int32_Int32_Impl_::$extraBits;
						$high2 = $tmp16 >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($tmp16,$ret4);
					}
					$tmp17 = $high2 + (haxe__Int32_Int32_Impl_::mul($multiplier->low, $digit->high) + haxe__Int32_Int32_Impl_::mul($multiplier->high, $digit->low) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) << haxe__Int32_Int32_Impl_::$extraBits;
					$high2 = $tmp17 >> haxe__Int32_Int32_Impl_::$extraBits;
					$x6 = new haxe__Int64____Int64($high2, $low2);
					$b1 = $x6;
					$high3 = $current->high + $b1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$low3 = $current->low + $b1->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($low3, $current->low) < 0) {
						$ret5 = $high3++;
						$tmp18 = $high3 << haxe__Int32_Int32_Impl_::$extraBits;
						$high3 = $tmp18 >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($tmp18,$ret5);
					}
					$x7 = new haxe__Int64____Int64($high3, $low3);
					$current = $x7;
					if($current->high < 0) {
						throw new HException("NumberFormatError: Overflow");
					}
					unset($x7,$x6,$tmp17,$tmp15,$tmp14,$tmp12,$tmp11,$p111,$p101,$p011,$p001,$mask1,$low3,$low2,$high3,$high2,$bl1,$bh1,$b1,$al1,$ah1);
				}
				$mask2 = 65535;
				$al2 = $multiplier->low & $mask2;
				$ah2 = _hx_shift_right($multiplier->low, 16);
				$bl2 = $base->low & $mask2;
				$bh2 = _hx_shift_right($base->low, 16);
				$p002 = haxe__Int32_Int32_Impl_::mul($al2, $bl2);
				$p102 = haxe__Int32_Int32_Impl_::mul($ah2, $bl2);
				$p012 = haxe__Int32_Int32_Impl_::mul($al2, $bh2);
				$p112 = haxe__Int32_Int32_Impl_::mul($ah2, $bh2);
				$low4 = $p002;
				$high4 = ($p112 + (_hx_shift_right($p012, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) + (_hx_shift_right($p102, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$tmp19 = $p012 << 16 << haxe__Int32_Int32_Impl_::$extraBits;
				$p012 = $tmp19 >> haxe__Int32_Int32_Impl_::$extraBits;
				$tmp20 = $low4 + $p012 << haxe__Int32_Int32_Impl_::$extraBits;
				$low4 = $tmp20 >> haxe__Int32_Int32_Impl_::$extraBits;
				if(haxe__Int32_Int32_Impl_::ucompare($low4, $p012) < 0) {
					$ret6 = $high4++;
					$tmp21 = $high4 << haxe__Int32_Int32_Impl_::$extraBits;
					$high4 = $tmp21 >> haxe__Int32_Int32_Impl_::$extraBits;
					unset($tmp21,$ret6);
				}
				$tmp22 = $p102 << 16 << haxe__Int32_Int32_Impl_::$extraBits;
				$p102 = $tmp22 >> haxe__Int32_Int32_Impl_::$extraBits;
				$tmp23 = $low4 + $p102 << haxe__Int32_Int32_Impl_::$extraBits;
				$low4 = $tmp23 >> haxe__Int32_Int32_Impl_::$extraBits;
				if(haxe__Int32_Int32_Impl_::ucompare($low4, $p102) < 0) {
					$ret7 = $high4++;
					$tmp24 = $high4 << haxe__Int32_Int32_Impl_::$extraBits;
					$high4 = $tmp24 >> haxe__Int32_Int32_Impl_::$extraBits;
					unset($tmp24,$ret7);
				}
				$tmp25 = $high4 + (haxe__Int32_Int32_Impl_::mul($multiplier->low, $base->high) + haxe__Int32_Int32_Impl_::mul($multiplier->high, $base->low) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) << haxe__Int32_Int32_Impl_::$extraBits;
				$high4 = $tmp25 >> haxe__Int32_Int32_Impl_::$extraBits;
				$x8 = new haxe__Int64____Int64($high4, $low4);
				$multiplier = $x8;
				unset($x8,$x3,$tmp25,$tmp23,$tmp22,$tmp20,$tmp2,$tmp19,$tmp1,$p112,$p102,$p012,$p002,$mask2,$low4,$i,$high4,$digitInt,$digit,$bl2,$bh2,$al2,$ah2);
			}
		}
		{
			$GLOBALS['%s']->pop();
			return $current;
		}
		$GLOBALS['%s']->pop();
	}
	static function fromFloat($f) {
		$GLOBALS['%s']->push("haxe.Int64Helper::fromFloat");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = null;
		$tmp1 = !Math::isNaN($f);
		if($tmp1) {
			$tmp = !Math::isFinite($f);
		} else {
			$tmp = true;
		}
		if($tmp) {
			throw new HException("Number is NaN or Infinite");
		}
		$noFractions = $f - _hx_mod($f, 1);
		if($noFractions > 9007199254740991) {
			throw new HException("Conversion overflow");
		}
		if($noFractions < -9007199254740991) {
			throw new HException("Conversion underflow");
		}
		$x = new haxe__Int64____Int64(0, 0);
		$result = $x;
		$neg = $noFractions < 0;
		$rest = null;
		if($neg) {
			$rest = -$noFractions;
		} else {
			$rest = $noFractions;
		}
		$i = 0;
		while($rest >= 1) {
			$curr = _hx_mod($rest, 2);
			$rest /= 2;
			if($curr >= 1) {
				$x1 = new haxe__Int64____Int64(0, 1);
				$a = $x1;
				$b = $i;
				$b &= 63;
				$b1 = null;
				if($b === 0) {
					$x2 = new haxe__Int64____Int64($a->high, $a->low);
					$b1 = $x2;
					unset($x2);
				} else {
					if($b < 32) {
						$x3 = new haxe__Int64____Int64($a->high << $b << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits | _hx_shift_right($a->low, 32 - $b), $a->low << $b << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits);
						$b1 = $x3;
						unset($x3);
					} else {
						$x4 = new haxe__Int64____Int64($a->low << $b - 32 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits, 0);
						$b1 = $x4;
						unset($x4);
					}
				}
				$high = $result->high + $b1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$low = $result->low + $b1->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				if(haxe__Int32_Int32_Impl_::ucompare($low, $result->low) < 0) {
					++$high;
					$tmp2 = $high << haxe__Int32_Int32_Impl_::$extraBits;
					$high = $tmp2 >> haxe__Int32_Int32_Impl_::$extraBits;
					unset($tmp2);
				}
				$x5 = new haxe__Int64____Int64($high, $low);
				$result = $x5;
				unset($x5,$x1,$low,$high,$b1,$b,$a);
			}
			++$i;
			unset($curr);
		}
		if($neg) {
			$high1 = ~$result->high;
			$low1 = -$result->low;
			if($low1 === 0) {
				++$high1;
				$tmp3 = $high1 << haxe__Int32_Int32_Impl_::$extraBits;
				$high1 = $tmp3 >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			$x6 = new haxe__Int64____Int64($high1, $low1);
			$result = $x6;
		}
		{
			$GLOBALS['%s']->pop();
			return $result;
		}
		$GLOBALS['%s']->pop();
	}
	function __toString() { return 'haxe.Int64Helper'; }
}
