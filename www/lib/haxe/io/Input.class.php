<?php

// Generated by Haxe 3.3.0
class haxe_io_Input {
	public function __construct(){}
	public $bigEndian;
	public function readByte() {
		$GLOBALS['%s']->push("haxe.io.Input::readByte");
		$__hx__spos = $GLOBALS['%s']->length;
		throw new HException("Not implemented");
		$GLOBALS['%s']->pop();
	}
	public function readBytes($s, $pos, $len) {
		$GLOBALS['%s']->push("haxe.io.Input::readBytes");
		$__hx__spos = $GLOBALS['%s']->length;
		$k = $len;
		$b = $s->b;
		$tmp = null;
		$tmp1 = null;
		if($pos >= 0) {
			$tmp1 = $len < 0;
		} else {
			$tmp1 = true;
		}
		if(!$tmp1) {
			$tmp = $pos + $len > $s->length;
		} else {
			$tmp = true;
		}
		if($tmp) {
			throw new HException(haxe_io_Error::$OutsideBounds);
		}
		try {
			while($k > 0) {
				{
					$val = $this->readByte();
					$b->s[$pos] = chr($val);
					unset($val);
				}
				++$pos;
				--$k;
			}
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			if(($eof = $_ex_) instanceof haxe_io_Eof){
				$GLOBALS['%e'] = (new _hx_array(array()));
				while($GLOBALS['%s']->length >= $__hx__spos) {
					$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
				}
				$GLOBALS['%s']->push($GLOBALS['%e'][0]);
			} else throw $__hx__e;;
		}
		{
			$tmp2 = $len - $k;
			$GLOBALS['%s']->pop();
			return $tmp2;
		}
		$GLOBALS['%s']->pop();
	}
	public function close() {
		$GLOBALS['%s']->push("haxe.io.Input::close");
		$__hx__spos = $GLOBALS['%s']->length;
		$GLOBALS['%s']->pop();
	}
	public function set_bigEndian($b) {
		$GLOBALS['%s']->push("haxe.io.Input::set_bigEndian");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->bigEndian = $b;
		{
			$GLOBALS['%s']->pop();
			return $b;
		}
		$GLOBALS['%s']->pop();
	}
	public function readAll($bufsize = null) {
		$GLOBALS['%s']->push("haxe.io.Input::readAll");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = $bufsize === null;
		if($tmp) {
			$bufsize = 8192;
		}
		$buf = haxe_io_Bytes::alloc($bufsize);
		$total = new haxe_io_BytesBuffer();
		try {
			while(true) {
				$len = $this->readBytes($buf, 0, $bufsize);
				if($len === 0) {
					throw new HException(haxe_io_Error::$Blocked);
				}
				{
					$tmp1 = null;
					if($len >= 0) {
						$tmp1 = $len > $buf->length;
					} else {
						$tmp1 = true;
					}
					if($tmp1) {
						throw new HException(haxe_io_Error::$OutsideBounds);
					}
					$s = substr($buf->b->s, 0, $len);
					$x = new php__BytesData_Wrapper($s);
					$total->b .= _hx_string_or_null($x->s);
					unset($x,$tmp1,$s);
				}
				unset($len);
			}
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			if(($e = $_ex_) instanceof haxe_io_Eof){
				$GLOBALS['%e'] = (new _hx_array(array()));
				while($GLOBALS['%s']->length >= $__hx__spos) {
					$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
				}
				$GLOBALS['%s']->push($GLOBALS['%e'][0]);
			} else throw $__hx__e;;
		}
		{
			$tmp2 = $total->getBytes();
			$GLOBALS['%s']->pop();
			return $tmp2;
		}
		$GLOBALS['%s']->pop();
	}
	public function readFullBytes($s, $pos, $len) {
		$GLOBALS['%s']->push("haxe.io.Input::readFullBytes");
		$__hx__spos = $GLOBALS['%s']->length;
		while($len > 0) {
			$k = $this->readBytes($s, $pos, $len);
			if($k === 0) {
				throw new HException(haxe_io_Error::$Blocked);
			}
			$pos += $k;
			$len -= $k;
			unset($k);
		}
		$GLOBALS['%s']->pop();
	}
	public function read($nbytes) {
		$GLOBALS['%s']->push("haxe.io.Input::read");
		$__hx__spos = $GLOBALS['%s']->length;
		$s = haxe_io_Bytes::alloc($nbytes);
		$p = 0;
		while($nbytes > 0) {
			$k = $this->readBytes($s, $p, $nbytes);
			if($k === 0) {
				throw new HException(haxe_io_Error::$Blocked);
			}
			$p += $k;
			$nbytes -= $k;
			unset($k);
		}
		{
			$GLOBALS['%s']->pop();
			return $s;
		}
		$GLOBALS['%s']->pop();
	}
	public function readUntil($end) {
		$GLOBALS['%s']->push("haxe.io.Input::readUntil");
		$__hx__spos = $GLOBALS['%s']->length;
		$buf = new StringBuf();
		$last = null;
		while(true) {
			$last = $this->readByte();
			if(!($last !== $end)) {
				break;
			}
			$buf->b .= _hx_string_or_null(chr($last));
		}
		{
			$tmp = $buf->b;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function readLine() {
		$GLOBALS['%s']->push("haxe.io.Input::readLine");
		$__hx__spos = $GLOBALS['%s']->length;
		$buf = new StringBuf();
		$last = null;
		$s = null;
		try {
			while(true) {
				$last = $this->readByte();
				if(!($last !== 10)) {
					break;
				}
				$buf->b .= _hx_string_or_null(chr($last));
			}
			$s = $buf->b;
			$tmp = strlen($s) - 1;
			$tmp1 = _hx_char_code_at($s, $tmp);
			if($tmp1 === 13) {
				$s = _hx_substr($s, 0, -1);
			}
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			if(($e = $_ex_) instanceof haxe_io_Eof){
				$GLOBALS['%e'] = (new _hx_array(array()));
				while($GLOBALS['%s']->length >= $__hx__spos) {
					$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
				}
				$GLOBALS['%s']->push($GLOBALS['%e'][0]);
				$s = $buf->b;
				if(strlen($s) === 0) {
					throw new HException($e);
				}
			} else throw $__hx__e;;
		}
		{
			$GLOBALS['%s']->pop();
			return $s;
		}
		$GLOBALS['%s']->pop();
	}
	public function readFloat() {
		$GLOBALS['%s']->push("haxe.io.Input::readFloat");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = $this->readInt32();
		{
			$tmp2 = haxe_io_FPHelper::i32ToFloat($tmp);
			$GLOBALS['%s']->pop();
			return $tmp2;
		}
		$GLOBALS['%s']->pop();
	}
	public function readDouble() {
		$GLOBALS['%s']->push("haxe.io.Input::readDouble");
		$__hx__spos = $GLOBALS['%s']->length;
		$i1 = $this->readInt32();
		$i2 = $this->readInt32();
		$tmp = $this->bigEndian;
		if($tmp) {
			$tmp2 = haxe_io_FPHelper::i64ToDouble($i2, $i1);
			$GLOBALS['%s']->pop();
			return $tmp2;
		} else {
			$tmp2 = haxe_io_FPHelper::i64ToDouble($i1, $i2);
			$GLOBALS['%s']->pop();
			return $tmp2;
		}
		$GLOBALS['%s']->pop();
	}
	public function readInt8() {
		$GLOBALS['%s']->push("haxe.io.Input::readInt8");
		$__hx__spos = $GLOBALS['%s']->length;
		$n = $this->readByte();
		if($n >= 128) {
			$tmp = $n - 256;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		{
			$GLOBALS['%s']->pop();
			return $n;
		}
		$GLOBALS['%s']->pop();
	}
	public function readInt16() {
		$GLOBALS['%s']->push("haxe.io.Input::readInt16");
		$__hx__spos = $GLOBALS['%s']->length;
		$ch1 = $this->readByte();
		$ch2 = $this->readByte();
		$n = null;
		if($this->bigEndian) {
			$n = $ch2 | $ch1 << 8;
		} else {
			$n = $ch1 | $ch2 << 8;
		}
		if(($n & 32768) !== 0) {
			$tmp = $n - 65536;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		{
			$GLOBALS['%s']->pop();
			return $n;
		}
		$GLOBALS['%s']->pop();
	}
	public function readUInt16() {
		$GLOBALS['%s']->push("haxe.io.Input::readUInt16");
		$__hx__spos = $GLOBALS['%s']->length;
		$ch1 = $this->readByte();
		$ch2 = $this->readByte();
		if($this->bigEndian) {
			$tmp = $ch2 | $ch1 << 8;
			$GLOBALS['%s']->pop();
			return $tmp;
		} else {
			$tmp = $ch1 | $ch2 << 8;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function readInt24() {
		$GLOBALS['%s']->push("haxe.io.Input::readInt24");
		$__hx__spos = $GLOBALS['%s']->length;
		$ch1 = $this->readByte();
		$ch2 = $this->readByte();
		$ch3 = $this->readByte();
		$n = null;
		if($this->bigEndian) {
			$n = $ch3 | $ch2 << 8 | $ch1 << 16;
		} else {
			$n = $ch1 | $ch2 << 8 | $ch3 << 16;
		}
		if(($n & 8388608) !== 0) {
			$tmp = $n - 16777216;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		{
			$GLOBALS['%s']->pop();
			return $n;
		}
		$GLOBALS['%s']->pop();
	}
	public function readUInt24() {
		$GLOBALS['%s']->push("haxe.io.Input::readUInt24");
		$__hx__spos = $GLOBALS['%s']->length;
		$ch1 = $this->readByte();
		$ch2 = $this->readByte();
		$ch3 = $this->readByte();
		if($this->bigEndian) {
			$tmp = $ch3 | $ch2 << 8 | $ch1 << 16;
			$GLOBALS['%s']->pop();
			return $tmp;
		} else {
			$tmp = $ch1 | $ch2 << 8 | $ch3 << 16;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function readInt32() {
		$GLOBALS['%s']->push("haxe.io.Input::readInt32");
		$__hx__spos = $GLOBALS['%s']->length;
		$ch1 = $this->readByte();
		$ch2 = $this->readByte();
		$ch3 = $this->readByte();
		$ch4 = $this->readByte();
		$n = null;
		if($this->bigEndian) {
			$n = $ch4 | $ch3 << 8 | $ch2 << 16 | $ch1 << 24;
		} else {
			$n = $ch1 | $ch2 << 8 | $ch3 << 16 | $ch4 << 24;
		}
		if(($n & -2147483648) !== 0) {
			$tmp = $n | -2147483648;
			$GLOBALS['%s']->pop();
			return $tmp;
		} else {
			$GLOBALS['%s']->pop();
			return $n;
		}
		$GLOBALS['%s']->pop();
	}
	public function readString($len) {
		$GLOBALS['%s']->push("haxe.io.Input::readString");
		$__hx__spos = $GLOBALS['%s']->length;
		$b = haxe_io_Bytes::alloc($len);
		$this->readFullBytes($b, 0, $len);
		{
			$tmp = $b->toString();
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $__properties__ = array("set_bigEndian" => "set_bigEndian");
	function __toString() { return 'haxe.io.Input'; }
}
