<?php

// Generated by Haxe 3.3.0
class haxe_ds_ArraySort {
	public function __construct(){}
	static function sort($a, $cmp) {
		$GLOBALS['%s']->push("haxe.ds.ArraySort::sort");
		$__hx__spos = $GLOBALS['%s']->length;
		haxe_ds_ArraySort::rec($a, $cmp, 0, $a->length);
		$GLOBALS['%s']->pop();
	}
	static function rec($a, $cmp, $from, $to) {
		$GLOBALS['%s']->push("haxe.ds.ArraySort::rec");
		$__hx__spos = $GLOBALS['%s']->length;
		$middle = $from + $to >> 1;
		if($to - $from < 12) {
			if($to <= $from) {
				$GLOBALS['%s']->pop();
				return;
			}
			{
				$_g1 = $from + 1;
				while($_g1 < $to) {
					$i = $_g1++;
					$j = $i;
					while($j > $from) {
						$tmp = $a[$j];
						$tmp1 = $a[$j - 1];
						$tmp2 = call_user_func_array($cmp, array($tmp, $tmp1)) < 0;
						if($tmp2) {
							haxe_ds_ArraySort::swap($a, $j - 1, $j);
						} else {
							break;
						}
						--$j;
						unset($tmp2,$tmp1,$tmp);
					}
					unset($j,$i);
				}
			}
			{
				$GLOBALS['%s']->pop();
				return;
			}
		}
		haxe_ds_ArraySort::rec($a, $cmp, $from, $middle);
		haxe_ds_ArraySort::rec($a, $cmp, $middle, $to);
		haxe_ds_ArraySort::doMerge($a, $cmp, $from, $middle, $to, $middle - $from, $to - $middle);
		$GLOBALS['%s']->pop();
	}
	static function doMerge($a, $cmp, $from, $pivot, $to, $len1, $len2) {
		$GLOBALS['%s']->push("haxe.ds.ArraySort::doMerge");
		$__hx__spos = $GLOBALS['%s']->length;
		$first_cut = null;
		$second_cut = null;
		$len11 = null;
		$len22 = null;
		$new_mid = null;
		$tmp = null;
		if($len1 !== 0) {
			$tmp = $len2 === 0;
		} else {
			$tmp = true;
		}
		if($tmp) {
			$GLOBALS['%s']->pop();
			return;
		}
		if($len1 + $len2 === 2) {
			$tmp1 = $a[$pivot];
			$tmp2 = $a[$from];
			$tmp3 = call_user_func_array($cmp, array($tmp1, $tmp2));
			if($tmp3 < 0) {
				haxe_ds_ArraySort::swap($a, $pivot, $from);
			}
			{
				$GLOBALS['%s']->pop();
				return;
			}
		}
		if($len1 > $len2) {
			$len11 = $len1 >> 1;
			$first_cut = $from + $len11;
			$second_cut = haxe_ds_ArraySort::lower($a, $cmp, $pivot, $to, $first_cut);
			$len22 = $second_cut - $pivot;
		} else {
			$len22 = $len2 >> 1;
			$second_cut = $pivot + $len22;
			$first_cut = haxe_ds_ArraySort::upper($a, $cmp, $from, $pivot, $second_cut);
			$len11 = $first_cut - $from;
		}
		haxe_ds_ArraySort::rotate($a, $cmp, $first_cut, $pivot, $second_cut);
		$new_mid = $first_cut + $len22;
		haxe_ds_ArraySort::doMerge($a, $cmp, $from, $first_cut, $new_mid, $len11, $len22);
		haxe_ds_ArraySort::doMerge($a, $cmp, $new_mid, $second_cut, $to, $len1 - $len11, $len2 - $len22);
		$GLOBALS['%s']->pop();
	}
	static function rotate($a, $cmp, $from, $mid, $to) {
		$GLOBALS['%s']->push("haxe.ds.ArraySort::rotate");
		$__hx__spos = $GLOBALS['%s']->length;
		$n = null;
		$tmp = null;
		if($from !== $mid) {
			$tmp = $mid === $to;
		} else {
			$tmp = true;
		}
		if($tmp) {
			$GLOBALS['%s']->pop();
			return;
		}
		$n = haxe_ds_ArraySort::gcd($to - $from, $mid - $from);
		while(true) {
			$tmp1 = $n--;
			if(!($tmp1 !== 0)) {
				break;
			}
			$val = $a[$from + $n];
			$shift = $mid - $from;
			$p1 = $from + $n;
			$p2 = $from + $n + $shift;
			while($p2 !== $from + $n) {
				$tmp2 = $a[$p2];
				$a[$p1] = $tmp2;
				$p1 = $p2;
				$tmp3 = $to - $p2 > $shift;
				if($tmp3) {
					$p2 += $shift;
				} else {
					$tmp4 = $shift - ($to - $p2);
					$p2 = $from + $tmp4;
					unset($tmp4);
				}
				unset($tmp3,$tmp2);
			}
			$a[$p1] = $val;
			unset($val,$tmp1,$shift,$p2,$p1);
		}
		$GLOBALS['%s']->pop();
	}
	static function gcd($m, $n) {
		$GLOBALS['%s']->push("haxe.ds.ArraySort::gcd");
		$__hx__spos = $GLOBALS['%s']->length;
		while($n !== 0) {
			$t = _hx_mod($m, $n);
			$m = $n;
			$n = $t;
			unset($t);
		}
		{
			$GLOBALS['%s']->pop();
			return $m;
		}
		$GLOBALS['%s']->pop();
	}
	static function upper($a, $cmp, $from, $to, $val) {
		$GLOBALS['%s']->push("haxe.ds.ArraySort::upper");
		$__hx__spos = $GLOBALS['%s']->length;
		$len = $to - $from;
		$half = null;
		$mid = null;
		while($len > 0) {
			$half = $len >> 1;
			$mid = $from + $half;
			$tmp = $a[$val];
			$tmp1 = $a[$mid];
			$tmp2 = call_user_func_array($cmp, array($tmp, $tmp1));
			if($tmp2 < 0) {
				$len = $half;
			} else {
				$from = $mid + 1;
				$tmp3 = $len - $half;
				$len = $tmp3 - 1;
				unset($tmp3);
			}
			unset($tmp2,$tmp1,$tmp);
		}
		{
			$GLOBALS['%s']->pop();
			return $from;
		}
		$GLOBALS['%s']->pop();
	}
	static function lower($a, $cmp, $from, $to, $val) {
		$GLOBALS['%s']->push("haxe.ds.ArraySort::lower");
		$__hx__spos = $GLOBALS['%s']->length;
		$len = $to - $from;
		$half = null;
		$mid = null;
		while($len > 0) {
			$half = $len >> 1;
			$mid = $from + $half;
			$tmp = $a[$mid];
			$tmp1 = $a[$val];
			$tmp2 = call_user_func_array($cmp, array($tmp, $tmp1));
			if($tmp2 < 0) {
				$from = $mid + 1;
				$tmp3 = $len - $half;
				$len = $tmp3 - 1;
				unset($tmp3);
			} else {
				$len = $half;
			}
			unset($tmp2,$tmp1,$tmp);
		}
		{
			$GLOBALS['%s']->pop();
			return $from;
		}
		$GLOBALS['%s']->pop();
	}
	static function swap($a, $i, $j) {
		$GLOBALS['%s']->push("haxe.ds.ArraySort::swap");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = $a[$i];
		$tmp1 = $a[$j];
		$a[$i] = $tmp1;
		$a[$j] = $tmp;
		$GLOBALS['%s']->pop();
	}
	static function compare($a, $cmp, $i, $j) {
		$GLOBALS['%s']->push("haxe.ds.ArraySort::compare");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = $a[$i];
		$tmp1 = $a[$j];
		{
			$tmp2 = call_user_func_array($cmp, array($tmp, $tmp1));
			$GLOBALS['%s']->pop();
			return $tmp2;
		}
		$GLOBALS['%s']->pop();
	}
	function __toString() { return 'haxe.ds.ArraySort'; }
}
