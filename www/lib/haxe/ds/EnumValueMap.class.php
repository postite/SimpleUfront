<?php

// Generated by Haxe 3.3.0
class haxe_ds_EnumValueMap extends haxe_ds_BalancedTree implements haxe_IMap{
	public function __construct() { if(!php_Boot::$skip_constructor) {
		$GLOBALS['%s']->push("haxe.ds.EnumValueMap::new");
		$__hx__spos = $GLOBALS['%s']->length;
		parent::__construct();
		$GLOBALS['%s']->pop();
	}}
	public function compare($k1, $k2) {
		$GLOBALS['%s']->push("haxe.ds.EnumValueMap::compare");
		$__hx__spos = $GLOBALS['%s']->length;
		$d = $k1->index - $k2->index;
		if($d !== 0) {
			$GLOBALS['%s']->pop();
			return $d;
		}
		$p1 = Type::enumParameters($k1);
		$p2 = Type::enumParameters($k2);
		$tmp = null;
		if($p1->length === 0) {
			$tmp = $p2->length === 0;
		} else {
			$tmp = false;
		}
		if($tmp) {
			$GLOBALS['%s']->pop();
			return 0;
		}
		{
			$tmp2 = $this->compareArgs($p1, $p2);
			$GLOBALS['%s']->pop();
			return $tmp2;
		}
		$GLOBALS['%s']->pop();
	}
	public function compareArgs($a1, $a2) {
		$GLOBALS['%s']->push("haxe.ds.EnumValueMap::compareArgs");
		$__hx__spos = $GLOBALS['%s']->length;
		$ld = $a1->length - $a2->length;
		if($ld !== 0) {
			$GLOBALS['%s']->pop();
			return $ld;
		}
		{
			$_g1 = 0;
			$_g = $a1->length;
			while($_g1 < $_g) {
				$i = $_g1++;
				$tmp = $a1[$i];
				$tmp1 = $a2[$i];
				$d = $this->compareArg($tmp, $tmp1);
				if($d !== 0) {
					$GLOBALS['%s']->pop();
					return $d;
				}
				unset($tmp1,$tmp,$i,$d);
			}
		}
		{
			$GLOBALS['%s']->pop();
			return 0;
		}
		$GLOBALS['%s']->pop();
	}
	public function compareArg($v1, $v2) {
		$GLOBALS['%s']->push("haxe.ds.EnumValueMap::compareArg");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = null;
		$tmp1 = Reflect::isEnumValue($v1);
		if($tmp1) {
			$tmp = Reflect::isEnumValue($v2);
		} else {
			$tmp = false;
		}
		if($tmp) {
			$tmp2 = $this->compare($v1, $v2);
			$GLOBALS['%s']->pop();
			return $tmp2;
		} else {
			$tmp2 = null;
			$tmp3 = Std::is($v1, _hx_qtype("Array"));
			if($tmp3) {
				$tmp2 = Std::is($v2, _hx_qtype("Array"));
			} else {
				$tmp2 = false;
			}
			if($tmp2) {
				$tmp4 = $this->compareArgs($v1, $v2);
				$GLOBALS['%s']->pop();
				return $tmp4;
			} else {
				$tmp4 = Reflect::compare($v1, $v2);
				$GLOBALS['%s']->pop();
				return $tmp4;
			}
		}
		$GLOBALS['%s']->pop();
	}
	function __toString() { return 'haxe.ds.EnumValueMap'; }
}
