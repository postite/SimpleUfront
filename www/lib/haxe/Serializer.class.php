<?php

// Generated by Haxe 3.3.0
class haxe_Serializer {
	public function __construct() {
		if(!php_Boot::$skip_constructor) {
		$GLOBALS['%s']->push("haxe.Serializer::new");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->buf = new StringBuf();
		$this->cache = new _hx_array(array());
		$this->useCache = haxe_Serializer::$USE_CACHE;
		$this->useEnumIndex = haxe_Serializer::$USE_ENUM_INDEX;
		$this->shash = new haxe_ds_StringMap();
		$this->scount = 0;
		$GLOBALS['%s']->pop();
	}}
	public $buf;
	public $cache;
	public $shash;
	public $scount;
	public $useCache;
	public $useEnumIndex;
	public function toString() {
		$GLOBALS['%s']->push("haxe.Serializer::toString");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = $this->buf->b;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function serializeString($s) {
		$GLOBALS['%s']->push("haxe.Serializer::serializeString");
		$__hx__spos = $GLOBALS['%s']->length;
		$x = $this->shash->get($s);
		if($x !== null) {
			$this->buf->add("R");
			$this->buf->add($x);
			{
				$GLOBALS['%s']->pop();
				return;
			}
		}
		$this->shash->set($s, $this->scount++);
		$this->buf->add("y");
		$s = rawurlencode($s);
		$this->buf->add(strlen($s));
		$this->buf->add(":");
		$this->buf->add($s);
		$GLOBALS['%s']->pop();
	}
	public function serializeRef($v) {
		$GLOBALS['%s']->push("haxe.Serializer::serializeRef");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$_g1 = 0;
			$_g = $this->cache->length;
			while($_g1 < $_g) {
				$i = $_g1++;
				$tmp = _hx_equal($this->cache[$i], $v);
				if($tmp) {
					$this->buf->add("r");
					$this->buf->add($i);
					{
						$GLOBALS['%s']->pop();
						return true;
					}
				}
				unset($tmp,$i);
			}
		}
		$this->cache->push($v);
		{
			$GLOBALS['%s']->pop();
			return false;
		}
		$GLOBALS['%s']->pop();
	}
	public function serializeFields($v) {
		$GLOBALS['%s']->push("haxe.Serializer::serializeFields");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$_g = 0;
			$_g1 = Reflect::fields($v);
			while($_g < $_g1->length) {
				$f = $_g1[$_g];
				++$_g;
				$this->serializeString($f);
				$tmp = Reflect::field($v, $f);
				$this->serialize($tmp);
				unset($tmp,$f);
			}
		}
		$this->buf->add("g");
		$GLOBALS['%s']->pop();
	}
	public function serialize($v) {
		$GLOBALS['%s']->push("haxe.Serializer::serialize");
		$__hx__spos = $GLOBALS['%s']->length;
		$_g = Type::typeof($v);
		$tmp = $_g->index;
		switch($tmp) {
		case 0:{
			$this->buf->add("n");
		}break;
		case 1:{
			$v1 = $v;
			if($v1 === 0) {
				$this->buf->add("z");
				{
					$GLOBALS['%s']->pop();
					return;
				}
			}
			$this->buf->add("i");
			$this->buf->add($v1);
		}break;
		case 2:{
			$v2 = $v;
			$tmp1 = Math::isNaN($v2);
			if($tmp1) {
				$this->buf->add("k");
			} else {
				$tmp2 = !Math::isFinite($v2);
				if($tmp2) {
					$tmp3 = null;
					if($v2 < 0) {
						$tmp3 = "m";
					} else {
						$tmp3 = "p";
					}
					$this->buf->add($tmp3);
				} else {
					$this->buf->add("d");
					$this->buf->add($v2);
				}
			}
		}break;
		case 3:{
			$tmp4 = null;
			if($v) {
				$tmp4 = "t";
			} else {
				$tmp4 = "f";
			}
			$this->buf->add($tmp4);
		}break;
		case 4:{
			$tmp5 = Std::is($v, _hx_qtype("Class"));
			if($tmp5) {
				$className = Type::getClassName($v);
				$this->buf->add("A");
				$this->serializeString($className);
			} else {
				$tmp6 = Std::is($v, _hx_qtype("Enum"));
				if($tmp6) {
					$this->buf->add("B");
					$this->serializeString(Type::getEnumName($v));
				} else {
					$tmp7 = null;
					$tmp8 = $this->useCache;
					if($tmp8) {
						$tmp7 = $this->serializeRef($v);
					} else {
						$tmp7 = false;
					}
					if($tmp7) {
						$GLOBALS['%s']->pop();
						return;
					}
					$this->buf->add("o");
					$this->serializeFields($v);
				}
			}
		}break;
		case 5:{
			throw new HException("Cannot serialize function");
		}break;
		case 6:{
			$c = _hx_deref($_g)->params[0];
			{
				if((is_object($_t = $c) && ($_t instanceof Enum) ? $_t == _hx_qtype("String") : _hx_equal($_t, _hx_qtype("String")))) {
					$this->serializeString($v);
					{
						$GLOBALS['%s']->pop();
						return;
					}
				}
				$tmp9 = null;
				$tmp10 = $this->useCache;
				if($tmp10) {
					$tmp9 = $this->serializeRef($v);
				} else {
					$tmp9 = false;
				}
				if($tmp9) {
					$GLOBALS['%s']->pop();
					return;
				}
				switch($c) {
				case _hx_qtype("Array"):{
					$ucount = 0;
					$this->buf->add("a");
					$l = _hx_len($v);
					{
						$_g1 = 0;
						$_g2 = $l;
						while($_g1 < $_g2) {
							$i = $_g1++;
							$tmp11 = $v[$i] === null;
							if($tmp11) {
								++$ucount;
							} else {
								if($ucount > 0) {
									if($ucount === 1) {
										$this->buf->add("n");
									} else {
										$this->buf->add("u");
										$this->buf->add($ucount);
									}
									$ucount = 0;
								}
								$tmp12 = $v[$i];
								$this->serialize($tmp12);
								unset($tmp12);
							}
							unset($tmp11,$i);
						}
					}
					if($ucount > 0) {
						if($ucount === 1) {
							$this->buf->add("n");
						} else {
							$this->buf->add("u");
							$this->buf->add($ucount);
						}
					}
					$this->buf->add("h");
				}break;
				case _hx_qtype("Date"):{
					$d = $v;
					$this->buf->add("v");
					$tmp13 = $d->getTime();
					$this->buf->add($tmp13);
				}break;
				case _hx_qtype("List"):{
					$this->buf->add("l");
					$v3 = $v;
					{
						$tmp14 = $v3->iterator();
						while(true) {
							$tmp15 = !$tmp14->hasNext();
							if($tmp15) {
								break;
							}
							$i1 = $tmp14->next();
							$this->serialize($i1);
							unset($tmp15,$i1);
						}
					}
					$this->buf->add("h");
				}break;
				case _hx_qtype("haxe.ds.IntMap"):{
					$this->buf->add("q");
					$v4 = $v;
					{
						$tmp16 = $v4->keys();
						while(true) {
							$tmp17 = !$tmp16->hasNext();
							if($tmp17) {
								break;
							}
							$k = $tmp16->next();
							$this->buf->add(":");
							$this->buf->add($k);
							$tmp18 = $v4->get($k);
							$this->serialize($tmp18);
							unset($tmp18,$tmp17,$k);
						}
					}
					$this->buf->add("h");
				}break;
				case _hx_qtype("haxe.ds.ObjectMap"):{
					$this->buf->add("M");
					$v5 = $v;
					{
						$tmp19 = new _hx_array_iterator(array_values($v5->hk));
						while(true) {
							$tmp20 = !$tmp19->hasNext();
							if($tmp20) {
								break;
							}
							$k1 = $tmp19->next();
							$this->serialize($k1);
							$tmp21 = $v5->get($k1);
							$this->serialize($tmp21);
							unset($tmp21,$tmp20,$k1);
						}
					}
					$this->buf->add("h");
				}break;
				case _hx_qtype("haxe.ds.StringMap"):{
					$this->buf->add("b");
					$v6 = $v;
					{
						$tmp22 = $v6->keys();
						while(true) {
							$tmp23 = !$tmp22->hasNext();
							if($tmp23) {
								break;
							}
							$k2 = $tmp22->next();
							$this->serializeString($k2);
							$tmp24 = $v6->get($k2);
							$this->serialize($tmp24);
							unset($tmp24,$tmp23,$k2);
						}
					}
					$this->buf->add("h");
				}break;
				case _hx_qtype("haxe.io.Bytes"):{
					$v7 = $v;
					$this->buf->add("s");
					$tmp25 = $v7->length * 8 / 6;
					$tmp26 = Math::ceil($tmp25);
					$this->buf->add($tmp26);
					$this->buf->add(":");
					$i2 = 0;
					$max = $v7->length - 2;
					$b64 = haxe_Serializer::$BASE64_CODES;
					if($b64 === null) {
						$length = strlen(haxe_Serializer::$BASE64);
						$this1 = (new _hx_array(array()));
						$this1->length = $length;
						$b64 = $this1;
						{
							$_g11 = 0;
							$_g3 = strlen(haxe_Serializer::$BASE64);
							while($_g11 < $_g3) {
								$i3 = $_g11++;
								{
									$val = _hx_char_code_at(haxe_Serializer::$BASE64, $i3);
									$b64[$i3] = $val;
									unset($val);
								}
								unset($i3);
							}
						}
						haxe_Serializer::$BASE64_CODES = $b64;
					}
					while($i2 < $max) {
						$pos = $i2++;
						$b1 = ord($v7->b->s[$pos]);
						$pos1 = $i2++;
						$b2 = ord($v7->b->s[$pos1]);
						$pos2 = $i2++;
						$b3 = ord($v7->b->s[$pos2]);
						$this->buf->b .= _hx_string_or_null(chr($b64[$b1 >> 2]));
						$this->buf->b .= _hx_string_or_null(chr($b64[($b1 << 4 | $b2 >> 4) & 63]));
						$this->buf->b .= _hx_string_or_null(chr($b64[($b2 << 2 | $b3 >> 6) & 63]));
						$this->buf->b .= _hx_string_or_null(chr($b64[$b3 & 63]));
						unset($pos2,$pos1,$pos,$b3,$b2,$b1);
					}
					if($i2 === $max) {
						$pos3 = $i2++;
						$b11 = ord($v7->b->s[$pos3]);
						$pos4 = $i2++;
						$b21 = ord($v7->b->s[$pos4]);
						$this->buf->b .= _hx_string_or_null(chr($b64[$b11 >> 2]));
						$this->buf->b .= _hx_string_or_null(chr($b64[($b11 << 4 | $b21 >> 4) & 63]));
						$this->buf->b .= _hx_string_or_null(chr($b64[$b21 << 2 & 63]));
					} else {
						if($i2 === $max + 1) {
							$pos5 = $i2++;
							$b12 = ord($v7->b->s[$pos5]);
							$this->buf->b .= _hx_string_or_null(chr($b64[$b12 >> 2]));
							$this->buf->b .= _hx_string_or_null(chr($b64[$b12 << 4 & 63]));
						}
					}
				}break;
				default:{
					$tmp27 = $this->useCache;
					if($tmp27) {
						$this->cache->pop();
					}
					$tmp28 = _hx_field($v, "hxSerialize") !== null;
					if($tmp28) {
						$this->buf->add("C");
						$this->serializeString(Type::getClassName($c));
						$tmp29 = $this->useCache;
						if($tmp29) {
							$this->cache->push($v);
						}
						$v->hxSerialize($this);
						$this->buf->add("g");
					} else {
						$this->buf->add("c");
						$this->serializeString(Type::getClassName($c));
						$tmp30 = $this->useCache;
						if($tmp30) {
							$this->cache->push($v);
						}
						$this->serializeFields($v);
					}
				}break;
				}
			}
		}break;
		case 7:{
			$e = _hx_deref($_g)->params[0];
			{
				$tmp31 = $this->useCache;
				if($tmp31) {
					$tmp32 = $this->serializeRef($v);
					if($tmp32) {
						$GLOBALS['%s']->pop();
						return;
					}
					$this->cache->pop();
				}
				$tmp33 = null;
				if($this->useEnumIndex) {
					$tmp33 = "j";
				} else {
					$tmp33 = "w";
				}
				$this->buf->add($tmp33);
				$this->serializeString(Type::getEnumName($e));
				$tmp34 = $this->useEnumIndex;
				if($tmp34) {
					$this->buf->add(":");
					$this->buf->add($v->index);
				} else {
					$this->serializeString($v->tag);
				}
				$this->buf->add(":");
				$l1 = count($v->params);
				$tmp35 = null;
				if($l1 !== 0) {
					$tmp35 = _hx_field($v, "params") === null;
				} else {
					$tmp35 = true;
				}
				if($tmp35) {
					$this->buf->add(0);
				} else {
					$this->buf->add($l1);
					{
						$_g12 = 0;
						$_g4 = $l1;
						while($_g12 < $_g4) {
							$i4 = $_g12++;
							$tmp36 = $v->params[$i4];
							$this->serialize($tmp36);
							unset($tmp36,$i4);
						}
					}
				}
				$tmp37 = $this->useCache;
				if($tmp37) {
					$this->cache->push($v);
				}
			}
		}break;
		default:{
			$tmp38 = Std::string($v);
			throw new HException("Cannot serialize " . _hx_string_or_null($tmp38));
		}break;
		}
		$GLOBALS['%s']->pop();
	}
	public function serializeException($e) {
		$GLOBALS['%s']->push("haxe.Serializer::serializeException");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->buf->add("x");
		$this->serialize($e);
		$GLOBALS['%s']->pop();
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $USE_CACHE = false;
	static $USE_ENUM_INDEX = false;
	static $BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
	static $BASE64_CODES = null;
	static function run($v) {
		$GLOBALS['%s']->push("haxe.Serializer::run");
		$__hx__spos = $GLOBALS['%s']->length;
		$s = new haxe_Serializer();
		$s->serialize($v);
		{
			$tmp = $s->toString();
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	function __toString() { return $this->toString(); }
}
